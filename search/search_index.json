{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u00d6nsoz","text":"<p>Son y\u0131llarda Git'in bir ana ak\u0131m VCS (Version Control System) haline geldi\u011fini s\u00f6ylemek yanl\u0131\u015f olmaz. Gerek hobi projelerde gerek profesyonel ekiplerde Git bir genel kabul olarak oturmu\u015f durumda. Bir\u00e7ok projenin geli\u015ftirilme s\u00fcrecindeki de\u011fi\u015fiklikleri y\u00f6netmek i\u00e7in gereksinim duyulan temel eylemleri Git ba\u015far\u0131yla sa\u011flayan bir ara\u00e7t\u0131r. Git'in yayg\u0131nl\u0131\u011f\u0131na \u00f6rnek olarak bir\u00e7o\u011fumuz g\u00fcnl\u00fck geli\u015ftirme s\u00fcre\u00e7lerimizde bir noktada temel Git komutlar\u0131 olan commit atma ve push atma eylemlerini ger\u00e7ekle\u015ftiriyoruz.</p> <p>Bu noktada uzun s\u00fcredir g\u00f6z\u00fcme \u00e7arpan, ve bence bir k\u00fclt\u00fcr haline gelmi\u015f olan, bir g\u00f6zlemi dile getirmek istiyorum. Git yayg\u0131n olarak kullan\u0131lan bir ara\u00e7 olmas\u0131na ra\u011fmen ne yapt\u0131\u011f\u0131 ve nas\u0131l \u00e7al\u0131\u015ft\u0131\u011f\u0131 anla\u015f\u0131lm\u0131yor. Bir\u00e7ok ekibin ve bir\u00e7ok insan\u0131n commit, push ve merge d\u0131\u015f\u0131nda bir kullan\u0131ma ihtiyac\u0131 olmuyor. Bu \u00fc\u00e7 eylem de yaln\u0131zca, kullan\u0131lan grafiksel uygulamalar ile (\u00f6rne\u011fin JetBrains, SourceTree, Visual Studio) veya GitHub veya GitLab gibi platformlar \u00fczerindeki grafiksel d\u00fc\u011fmeler ile ger\u00e7ekle\u015ftiriliyor. Bu durum \u00e7o\u011funlukla fazlas\u0131na ihtiya\u00e7 duymayan kullan\u0131c\u0131lar i\u00e7in yeterli oluyor. Ancak i\u015fler yolunda gitmedi\u011fi zaman eller ayaklara dola\u015fmaya ba\u015fl\u0131yor. Bu durum \u00f6rne\u011fin main branche uzun s\u00fcre \u00f6nce yanl\u0131\u015f bir development branch merge edilmi\u015f oldu\u011funun fark edildi\u011fi zaman bunun nas\u0131l oldu\u011funu ve nas\u0131l geri \u00e7evrilebilece\u011fini \u00e7\u00f6zmek i\u00e7in saatlerin harcanmas\u0131na sebep olabiliyor.</p> <p>Bu sorunu \"bilgi yetersizli\u011fi\" olarak \u00f6zetleyerek yaz\u0131y\u0131 noktalayabiliriz, ki yanl\u0131\u015f bir \u00e7\u0131kar\u0131m da olmaz. Ancak bana g\u00f6re bu durumda \"bilgi yetersizli\u011fi\" sadece bir semptom, bir sonu\u00e7 olarak meydana gelmekte. Bu semptomu olu\u015fturan farkl\u0131 bir sebep oldu\u011funu d\u00fc\u015f\u00fcn\u00fcyorum. Bana g\u00f6re bir\u00e7ok ki\u015fi odakland\u0131klar\u0131 \u015feylerin sadece sonu\u00e7lar\u0131yla ilgileniyor. Bunu yanl\u0131\u015f bir yakla\u015f\u0131m olarak isimlendirmemek gerekli. Bu yakla\u015f\u0131m genelde i\u015fe yar\u0131yor ve bu noktalarda b\u00fcy\u00fck bir mental y\u00fck tasarrufu sa\u011fl\u0131yor. G\u00fcnl\u00fck d\u00fczenli olarak kulland\u0131\u011f\u0131n\u0131z buzdolab\u0131n\u0131n motorunun hangi prensipleri kullanarak \u00e7al\u0131\u015ft\u0131\u011f\u0131n\u0131 bilmenin bize \u00e7ok bir faydas\u0131 olmayacakt\u0131r. Ancak sadece sonu\u00e7lara odaklanman\u0131n elimize aya\u011f\u0131m\u0131za dola\u015fmaya ba\u015flad\u0131\u011f\u0131 noktalar\u0131 g\u00f6zden ka\u00e7\u0131rmamam\u0131z gerekti\u011fini d\u00fc\u015f\u00fcn\u00fcyorum. Bu noktalara vard\u0131\u011f\u0131m\u0131z durumlarda bu faydac\u0131 \"sadece sonu\u00e7lara odaklanma\" yakla\u015f\u0131m\u0131n\u0131 de\u011fi\u015ftirmemizin bize b\u00fcy\u00fck faydas\u0131 olacakt\u0131r.</p> <p>Bir\u00e7o\u011fumuz kulland\u0131\u011f\u0131m\u0131z yaz\u0131l\u0131m ara\u00e7lar\u0131n\u0131n da sadece d\u00fczenli olarak kulland\u0131\u011f\u0131m\u0131z k\u0131s\u0131mlar\u0131n\u0131 \u00f6\u011freniyoruz. Bu \u00e7o\u011fu zaman zamandan tasarruf sa\u011flay\u0131p dikkatimizin da\u011f\u0131lmas\u0131n\u0131n \u00f6n\u00fcne ge\u00e7iyor. Git de bu kulland\u0131\u011f\u0131m\u0131z ara\u00e7lardan birisi. Ancak Git'in \u00e7ok \u00f6nemli bir fark\u0131 var. Git geli\u015ftirme s\u00fcre\u00e7lerimizin tam merkezinde yer alan bir ara\u00e7. Ayn\u0131 codebase \u00fczerinde birden \u00e7ok ki\u015finin bir arada birbirini engellemeden \u00e7al\u0131\u015fabilmesine olanak sa\u011fl\u0131yor. Codebase b\u00fcy\u00fcd\u00fck\u00e7e yap\u0131lan de\u011fi\u015fikliklerin kay\u0131t alt\u0131na al\u0131nmas\u0131n\u0131 ve takip edilmesini olduk\u00e7a kolayla\u015ft\u0131r\u0131yor. Geli\u015ftirici arkada\u015flar\u0131n yapt\u0131klar\u0131 geli\u015ftirmeden \u00e7ok projenin y\u00f6netimine zaman ay\u0131rmas\u0131n\u0131 engelliyor, ve bu sayede geli\u015ftirme s\u00fcre\u00e7lerimizin ivmelenmesini sa\u011fl\u0131yor. Sa\u011flad\u0131\u011f\u0131 kolayl\u0131klar\u0131 g\u00f6z \u00f6n\u00fcnde bulundurarak Git'in sadece bir commit atma arac\u0131 olarak g\u00f6r\u00fclmesinden \u00e7ok daha fazla ilgiyi hak etti\u011fi kanaatindeyim. Sonu\u00e7ta kulland\u0131\u011f\u0131m\u0131z buzdolab\u0131n\u0131n kullan\u0131m k\u0131lavuzunu okumaktan da zarar gelmez.</p> <p>Bu d\u00f6k\u00fcmanda referans olarak al\u0131nabilecek bir kaynak olu\u015fturmay\u0131 ama\u00e7l\u0131yorum. Git'in mental modeline bilgimin yetti\u011fi kadar de\u011finmeye \u00e7al\u0131\u015faca\u011f\u0131m. B\u00f6ylelikle Git'i her \u015feyin iyi gitmedi\u011fi durumlarda nas\u0131l faydal\u0131 bir \u015fekilde kullanabilece\u011fimizi daha iyi g\u00f6rece\u011fiz.</p>"},{"location":"baslamadan-once/","title":"Ba\u015flamadan \u00d6nce","text":"<p>Git \u00e7ok yetenekli ve s\u00fcrekli geli\u015fmekte olan bir ara\u00e7. Ben de hala baz\u0131 yeteneklerini ve u\u00e7 senaryosunu yeni ke\u015ffetmekteyim. Bu yaz\u0131n\u0131n amac\u0131 git'in b\u00fct\u00fcn yeteneklerine de\u011finmek de\u011fildir. Git'e giri\u015f 101 seviyesinden, yani branch a\u00e7\u0131p commit at\u0131p push atmak'tan daha ileri seviyeye dokunan T\u00fcrk\u00e7e bir kayna\u011fa pek denk gelemedi\u011fim i\u00e7in bu dok\u00fcman\u0131 haz\u0131rlamak istedim. Bu yaz\u0131ya ek olarak her zaman git'in kullanma k\u0131lavuzunu veya dok\u00fcman\u0131n\u0131 okuman\u0131z\u0131 tavsiye ederim. Burada verebilece\u011fimden \u00e7ok daha fazlas\u0131n\u0131 bar\u0131nd\u0131ran bir kaynakt\u0131r.</p> <p>Bu dok\u00fcman\u0131 haz\u0131rlarken kulland\u0131\u011f\u0131m git versiyonu a\u015fa\u011f\u0131dad\u0131r.</p> <p>Komutlar</p> <p><code>$</code> ba\u015flayan sat\u0131rlardaki komutlar\u0131 terminalde \u00e7al\u0131\u015ft\u0131rabilirsiniz. Yaz\u0131 boyunca bu format\u0131 s\u00fcrd\u00fcrmeye devam edece\u011fim. B\u00f6ylece komutlar ile \u00e7\u0131kt\u0131lar\u0131 ay\u0131rt etmek kolayla\u015facakt\u0131r.</p> <pre><code>$ git --version\ngit version 2.48.1\n</code></pre> <p>Varsay\u0131lan Bilgi Seviyesi</p> <p>Basit seviyede git bilginizin oldu\u011funu ve git ile \u00e7al\u0131\u015fm\u0131\u015f oldu\u011funuz varsayarak yaz\u0131ya devam edece\u011fim. Temellere elimden geldi\u011fince de\u011finmeye \u00e7al\u0131\u015facak olsam da bu yaz\u0131n\u0131n ana amac\u0131 git'i 101 seviyesinden \u00f6te anlamaya yard\u0131mc\u0131 olacak bir T\u00fcrk\u00e7e kaynak olu\u015fturmakt\u0131r.</p> <p>Varsay\u0131lan Sistem</p> <p>Bu dok\u00fcman\u0131 Unix bir sistemde \u00e7al\u0131\u015f\u0131ld\u0131\u011f\u0131n\u0131 varsayarak haz\u0131rl\u0131yorum. Yaz\u0131da herhangi bir g\u00f6rsel uygulama (JetBrains, SourceTree, Visual Studio) kullanmaktan ka\u00e7\u0131naca\u011f\u0131m. Sadece shell komutlar\u0131 \u00fczerinden anlat\u0131m yapaca\u011f\u0131m. MacOS veya Linux bir i\u015fletim sistemindeyseniz \u00e7al\u0131\u015ft\u0131r\u0131lan komutlarda bir uyumsuzluk ya\u015famayacaks\u0131n\u0131z. Windows'ta \u00e7al\u0131\u015f\u0131yorsan\u0131z WSL (Windows Subsystem for Linux) kurarak bir Linux alt sistemi i\u00e7erisinde Terminal ba\u015flatarak \u00e7al\u0131\u015fman\u0131z\u0131 \u00f6neririm. Aksi takdirde Windows'un komut sistemi Unix sistemlerine g\u00f6re \u00f6nemli davran\u0131\u015f farkl\u0131klar\u0131 sergiledi\u011fi i\u00e7in uyum sorunlar\u0131 ya\u015faman\u0131z ka\u00e7\u0131n\u0131lmaz olacakt\u0131r.</p> <p>Unix Bilgisi</p> <p>Git konusunda h\u0131zl\u0131ca bilgi almak isterseniz terminalinizde her zaman a\u015fa\u011f\u0131daki komutlardan birini \u00e7al\u0131\u015ft\u0131rabilirsiniz. Bunu <code>git</code> haricinde de kulland\u0131\u011f\u0131n\u0131z bir \u00e7ok ara\u00e7 i\u00e7in uygulayabilirsiniz. <code>#</code> karakterinden sonraki k\u0131s\u0131m yorum olarak kabul edilir. <pre><code>$ man git # git'in kullanma k\u0131lavuzunu a\u00e7ar\n$ git --help\n$ git &lt;command&gt; --help # \u00f6rne\u011fin: git commit --help\n</code></pre></p>"},{"location":"commit-graph-relation/","title":"Commit Graf\u0131 / Soya\u011fac\u0131 \u0130li\u015fkisi","text":"<p>\u00d6nceki b\u00f6l\u00fcmlerde fast-forward merge'ye de\u011finirken bahsetti\u011fimiz \u00f6nemli bir durum vard\u0131. Bir branch di\u011fer branch'i kaps\u0131yor mu? Bu sorgunun bizim i\u00e7in \u00f6nemi fast-forward merge b\u00f6l\u00fcm\u00fcnde \u00f6ne \u00e7\u0131km\u0131\u015ft\u0131. Fakat bu sorgunun ima ettiklerinin ayr\u0131 bir b\u00f6l\u00fcmde de\u011finilmeyi gerektirdi\u011fini d\u00fc\u015f\u00fcn\u00fcyorum.</p> <p>Mental Model</p> <p>Bu konuda git'i mental olarak modelleme bi\u00e7imimizi tekrar g\u00f6zden ge\u00e7irmemizde fayda olacakt\u0131r. Bir branch bir commit'e i\u015faret eden bir i\u015faret\u00e7idir. Di\u011fer bir deyi\u015fle bir branch ayn\u0131 anda birden \u00e7ok commit'e de\u011fil, yaln\u0131zca tek bir commit'e i\u015faret eder.</p> <p>Bir commit ise bir commit graf\u0131n\u0131n bir par\u00e7as\u0131d\u0131r ve kendisinden \u00f6nceki commit'e veya commit'lere parent ili\u015fkisiyle ba\u011fl\u0131d\u0131r.</p> <p>Bir branch'in di\u011ferini kaps\u0131yor olmas\u0131 durumu asl\u0131nda birka\u00e7 olay sonucunda ger\u00e7ekle\u015febilir. <code>A</code> ve <code>B</code> isminde iki branch'imiz olsun. <code>B</code> branch'i <code>A</code> branch'ini kaps\u0131yor ( \\(\\text{branch}_B \\supseteq \\text{branch}_A\\) ) \u00f6nermesi a\u015fa\u011f\u0131daki durumlarda ger\u00e7ekle\u015febilir:</p> <ul> <li><code>B</code> ile <code>A</code> branch'i ayn\u0131 commit'e i\u015faret ediyordur.</li> <li><code>B</code> branch'i <code>A</code> branch'inden olu\u015fturulmu\u015f ve <code>B</code> branch'i <code>A</code> branch'ine merge edilmeden \u00f6nce <code>A</code> branch'inin i\u015faret etti\u011fi commit de\u011fi\u015fmemi\u015ftir. Yani <code>A</code> branch'i, <code>B</code> branch'inin atas\u0131d\u0131r.</li> <li><code>A</code> branch'i <code>B</code> branch'ine bir merge commit ile merge edilmi\u015ftir.</li> </ul> <p>Fakat burada bu sorguyu branch'ler ile de\u011fil de commit'ler ile ele almak daha do\u011fru \u00e7\u0131kar\u0131mlara ula\u015fmam\u0131za yard\u0131mc\u0131 olacakt\u0131r. Bizim <code>A</code> veya <code>B</code> branch'i olarak isimlendirdi\u011fimiz yap\u0131lar asl\u0131nda bahsi ge\u00e7en anda bu branch'lerin bakt\u0131\u011f\u0131 commit'ler olarak d\u00fc\u015f\u00fcn\u00fclmelidir. Aksi takdirde yanl\u0131\u015f varsay\u0131mlarla yanl\u0131\u015f sonu\u00e7lara ula\u015fabiliriz.</p> <p>Branch terimini ortadan kald\u0131r\u0131p yerine commit terimini kullanmaya ba\u015flad\u0131\u011f\u0131m\u0131z zaman, kapsamak olarak isimlendirdi\u011fimiz durum asl\u0131nda basit\u00e7e bir commit'in di\u011fer commit'in atas\u0131 olmas\u0131n\u0131 ima etmektedir.</p> <p>X ve Y hash'li iki commit'imiz olsun. X commit'inin parent commit graf\u0131n\u0131 gezerek Y commit'ine ula\u015fabiliyorsak Y commit'i X commit'inin atas\u0131d\u0131r diyebiliriz.</p> <p>\u015eimdi \u00fczerinde \u00e7al\u0131\u015ft\u0131\u011f\u0131m\u0131z repository'mize d\u00f6n\u00fcp bu sorguyu farkl\u0131 commit ikilileri i\u00e7in deneyelim.</p> <pre><code>$ git log --graph --all --oneline\n* 7894926 (HEAD -&gt; dal-A) squash merge dal-B\n*   eb02546 Merge branch 'dal-B' into dal-A\n|\\  \n* | 8cd6f22 test.txt dal-A icin degistirdim\n| | * 5fa6930 (dal-B) degisiklik-2\n| | * 8dd8796 degisiklik-1\n| |/  \n| * 2c6d144 test.txt dal-B icin degistirdim\n|/  \n* cef4e44 (main) dal-B icin degisiklik yaptim\n*   b5b6c09 Merge branch 'yeni-branch'\n|\\  \n| * dc2243f (yeni-branch-2, yeni-branch) yeni-branch icin ilk commitimi atiyorum\n* | 9a63d64 test-2.txt dosyasini ekledim\n|/  \n* 777f68a Dosyaya Merhaba Dunya ekledim\n* 95e7356 Ilk commit\n</code></pre>"},{"location":"commit-graph-relation/#sorgular","title":"Sorgular","text":""},{"location":"commit-graph-relation/#repositorydeki-ilk-commit-mevcut-commitimizin-atas-m","title":"Repository'deki ilk commit, mevcut commit'imizin atas\u0131 m\u0131?","text":"<p>Repository'mizin mevcuttaki halinde bu sorgunun cevab\u0131 her zaman evet olacakt\u0131r. Ancak bunu bir komut ile do\u011frulayal\u0131m.</p> <p>Terminoloji</p> <p>Bir git repository'sinde hi\u00e7bir atas\u0131 olmayan commit'lere root commit ad\u0131 verilir. T\u00fcrk\u00e7ede k\u00f6k commit diye isimlendirebiliriz.</p> Birden \u00e7ok root commit <p>Bir git repository'sinde birden \u00e7ok root commit bulunmas\u0131 m\u00fcmk\u00fcnd\u00fcr. Bunu ger\u00e7ekle\u015ftirmenin yollar\u0131ndan birisi orphan bir branch olu\u015fturmakt\u0131r. Bunu checkout yaparken <code>--orphan</code> bayra\u011f\u0131 ile yeni bir branch olu\u015fturarak ger\u00e7ekle\u015ftirebiliriz.</p> <p>Daha sonra log'u <code>--all --max-parents=0</code> bayraklar\u0131 ile sadece root commit'leri g\u00f6sterecek \u015fekilde ayarlayarak birden \u00e7ok root commit'imizin oldu\u011funu do\u011frulayabiliriz. <pre><code>$ git checkout --orphan yeni-bir-branch\nSwitched to a new branch 'yeni-bir-branch'\n\n# eski commit'ten kalan dizin yapisini temizleyelim\n$ git rm -rf .\nrm 'test-2.txt'\nrm 'test.txt'\n\n$ echo \"Yeni Bir Baslangic Yapiyorum\" &gt; yeni-bir-baslangic.txt\n\n$ git add yeni-bir-baslangic.txt\n\n$ git commit -m \"yeni bir baslangic\"\n[yeni-bir-branch (root-commit) 7eb6f87] yeni bir baslangic\n 1 file changed, 1 insertion(+)\n create mode 100644 yeni-bir-baslangic.txt\n\n$ git log --all --max-parents=0\ncommit 7eb6f87f0dae69f6a068004caea18eb0b3868e51 (HEAD -&gt; yeni-bir-branch)\nAuthor: &lt;username&gt; &lt;email&gt;\nDate:   Sun May 4 13:58:48 2025 +0200\n\n    yeni bir baslangic\n\ncommit 95e7356f75c2d844d9d1d7ba42fd5b40a5fd5ecf\nAuthor: &lt;username&gt; &lt;email&gt;\nDate:   Fri May 2 21:49:02 2025 +0200\n\n    Ilk commit\n</code></pre> \u015eimdi ise <code>git checkout dal-A</code> ile \u00f6nceki branch'imize geri d\u00f6nelim.</p> <p><code>git log</code> i\u00e7in <code>--all</code> bayra\u011f\u0131</p> <p>Sorgular\u0131m\u0131z i\u00e7in log'u filtrelerken <code>--all</code> bayra\u011f\u0131n\u0131 kullanmamam\u0131z gerekiyor, aksi takdirde mevcut commit graf\u0131ndan ziyade b\u00fct\u00fcn repository'nin commit history'sini yazd\u0131raca\u011f\u0131 i\u00e7in yanl\u0131\u015f sonu\u00e7lara varmam\u0131za sebep olacakt\u0131r.</p> <pre><code>$ git log --oneline | grep \"95e7356\"\n95e7356 Ilk commit\n</code></pre> <p>Unix Bilgisi</p> <p><code>grep</code> Unix sistemlerde kurulu olarak gelen bir programd\u0131r. Bir dosyan\u0131n veya kendisine beslenen bir girdinin belli bir filtreye uyan sat\u0131rlar\u0131n\u0131 yazd\u0131rmaya yarar.</p> <p><code>|</code> (pipe) operat\u00f6r\u00fc ile bir \u00f6nceki komutun \u00e7\u0131kt\u0131s\u0131n\u0131 bir sonraki komuta girdi olarak besleyebiliyor, di\u011fer bir deyi\u015fle pipe'leyebiliyoruz. <code>| grep \"95e7356\"</code> yaparak <code>git log</code> komutunun \u00e7\u0131kt\u0131s\u0131n\u0131 <code>grep</code> program\u0131na girdi olarak besledik ve <code>grep</code> de bize sadece ve sadece <code>\"95e7356\"</code> k\u0131sm\u0131n\u0131 i\u00e7eren sat\u0131rlar\u0131 \u00e7\u0131kard\u0131.</p> <p>Yukar\u0131daki komut ile mevcut history graf\u0131m\u0131z\u0131 yazd\u0131rd\u0131k ve <code>grep</code> ile bu graf\u0131 filtreleyerek repository'deki ilk commit mevcut history'mizde var m\u0131 yok mu sorgusuna cevab\u0131m\u0131z\u0131 \"evet\" olarak bulduk.</p>"},{"location":"commit-graph-relation/#yeni-branch-isimli-branchin-baktg-commit-su-anki-commitimizin-atas-m","title":"<code>yeni-branch</code> isimli branch'in bakt\u0131\u011f\u0131 commit, \u015fu anki commit'imizin atas\u0131 m\u0131?","text":"<pre><code>$ git log --oneline | grep \"dc2243f\"\ndc2243f (yeni-branch-2, yeni-branch) yeni-branch icin ilk commitimi atiyorum\n</code></pre> <p><code>yeni-branch</code> isimli branch'i bir merge commit ile commit history'mize, di\u011fer bir deyi\u015fle soya\u011fac\u0131m\u0131za ba\u011flam\u0131\u015ft\u0131k ve bunun sonucunda art\u0131k onun da mevcut commit'imizin bir atas\u0131 oldu\u011funu g\u00f6rebiliyoruz.</p>"},{"location":"commit-graph-relation/#dal-b-branchinin-baktg-commit-su-anki-commitimizin-atas-m","title":"<code>dal-B</code> branch'inin bakt\u0131\u011f\u0131 commit, \u015fu anki commit'imizin atas\u0131 m\u0131?","text":"<p>Hat\u0131rlarsan\u0131z <code>dal-B</code> branch'ine 2 yeni commit at\u0131p onu daha sonra squash merge ile <code>dal-A</code> branch'imize merge etmi\u015ftik.</p> <pre><code>$ git log --oneline | grep \"5fa6930\"\n</code></pre> <p>Yukar\u0131daki komutun hi\u00e7bir \u00e7\u0131kt\u0131s\u0131 vermemesiyle a\u015fikar oldu\u011fu \u00fczere <code>dal-B</code> branch'i \u015fu anda <code>dal-A</code> branch'inin bakt\u0131\u011f\u0131 commit'in bir atas\u0131 olarak g\u00f6r\u00fcnm\u00fcyor. <code>dal-B</code> branch'ini merge etmi\u015f olmam\u0131za ra\u011fmen, yapt\u0131\u011f\u0131m\u0131z merge i\u015flemi squash merge oldu\u011fu i\u00e7in asl\u0131nda <code>dal-B</code> branch'ini <code>dal-A</code> branch'ine ba\u011flayan herhangi bir commit olu\u015fmam\u0131\u015f oluyor. Squash merge ile birlikte asl\u0131nda <code>dal-A</code> branch'ine yaln\u0131zca ba\u011f\u0131ms\u0131z yeni bir commit atm\u0131\u015f oluyoruz.</p> <p>Buradan yola \u00e7\u0131karak ne zaman squash merge yapmak istedi\u011fimize dikkat etmekte fayda oldu\u011funu s\u00f6yleyebiliriz. Branch'ler veya commitler aras\u0131 soya\u011fac\u0131 ili\u015fkisini korumak istiyorsak squash merge yapmaktan ka\u00e7\u0131nmal\u0131y\u0131z.</p> <p>Alternatif komutlar</p> <p>Bu \u015fekilde log'u kullanarak commit soya\u011fac\u0131n\u0131 sorgulamak yanl\u0131\u015f bir yakla\u015f\u0131m olmasa da, git'in bu ama\u00e7 i\u00e7in kullanabilece\u011fimiz farkl\u0131 komutlar\u0131 da mevcut.</p> <ul> <li> <p><code>rev-list</code> belirtilen commit'in ula\u015fabildi\u011fi b\u00fct\u00fcn commit hash'lerini listeler. <code>log</code> komutu insan taraf\u0131ndan okunabilen bir komut iken <code>rev-list</code> script amac\u0131yla kullan\u0131lan bir komuttur.</p> <p>Terminoloji</p> <p>Git komutlar\u0131ndan bahsederken insan taraf\u0131ndan okunabilmesi ama\u00e7lanan komutlara porcelain s\u0131fat\u0131 kullan\u0131l\u0131r. <code>git log</code> bir porselen komut iken <code>rev-list</code> bir porselen komut de\u011fildir.</p> <pre><code>$ git rev-list dal-A | grep \"dc2243f197f26719f94687238bb0f9310da223d2\"\ndc2243f197f26719f94687238bb0f9310da223d2\n</code></pre> </li> <li> <p><code>merge-base</code> komutu <code>--is-ancestor</code> bayra\u011f\u0131 ile kullan\u0131ld\u0131\u011f\u0131 zaman bir commit di\u011ferinin atas\u0131dir \u00f6nermesi do\u011fru ise <code>0</code> kodu ile, yanl\u0131\u015f ise <code>0</code>'dan farkl\u0131 bir kod ile \u00e7\u0131k\u0131\u015f yapar. <pre><code># `yeni-branch` isimli branch'in isaret ettigi commit\n# `dal-A` branch'inin isaret ettigi commit'in atasi mi?\n# $? ile bir onceki komutun cikis kodunu alip bunu da `echo` ile yazdirabiliriz.\n$ git merge-base --is-ancestor yeni-branch dal-A &amp;&amp; echo $?\n0\n</code></pre> <pre><code># `dal-B` isimli branch'in isaret ettigi commit\n# `dal-A` branch'inin isaret ettigi commit'in atasi mi?\n# Burada bir onceki komutun aksine `||` operatorunu kullanmamiz gerekiyor\n# aksi taktirde `&amp;&amp;` kullansaydik sol taraftaki komut\n# 0'dan farkli bir kod ile cikis yapacagi icin sagdaki komut hic calismayacakti.\n$ git merge-base --is-ancestor dal-B dal-A || echo $?\n1\n</code></pre></p> </li> </ul>"},{"location":"merge/conflict/","title":"Conflict","text":"<p>Biri di\u011ferini kapsayan iki branch i\u00e7in merge i\u015fleminde fast-forward merge yap\u0131larak i\u015flemin sadele\u015ftirildi\u011fini \u00f6\u011frendik. Bunun \u00fczerine birbirinden ayr\u0131lm\u0131\u015f olan bir branch'i di\u011ferine merge ederken fast-forward'in m\u00fcmk\u00fcn olmad\u0131\u011f\u0131n\u0131 \u00f6\u011frendik. \u015eimdi ise merge konusunda kar\u015f\u0131la\u015f\u0131labilecek bir duruma de\u011finece\u011fim. Bunu bir \u00f6rnek ile anlatal\u0131m.</p> <p><code>A</code> ve <code>B</code> isminde iki branch'imiz oldu\u011funu varsayal\u0131m. <code>A</code> branch'indeyken <code>test.txt</code> dosyas\u0131n\u0131n ilk sat\u0131r\u0131n\u0131 de\u011fi\u015ftirip bir commit att\u0131k. Art\u0131k <code>A</code> branch'imizde bu de\u011fi\u015fiklik bulunmakta. <code>B</code> branch'indeyken de ayn\u0131 i\u015flemi tekrarlad\u0131m ve ilk sat\u0131r\u0131 de\u011fi\u015ftirerek commit att\u0131k. Art\u0131k birbirinden ayr\u0131 ve ayn\u0131 dosya \u00fczerinde farkl\u0131 de\u011fi\u015fiklikleri olan 2 branch'imiz var. Peki bu durumda <code>B</code> branch'ini <code>A</code> branch'ine merge etmek istersek, git <code>test.txt</code> dosyas\u0131ndaki iki farkl\u0131 branch'teki de\u011fi\u015fikli\u011fi nas\u0131l birle\u015ftirecek?</p> <pre><code>$ git checkout -b dal-A\nSwitched to a new branch 'dal-A'\n\n# burada test.txt dosyasini acip ilk satiri degistirelim. Sonrasinda ise siradaki komuttan devam edelim.\n\n$ cat test.txt\ndal-A icin Hello world satiri yaziyorum\nMerhaba Dunya\nyeni-branch icin merhaba-dunya\ndal B icin degisiklik\n\n$ git add test.txt\n\n$ git commit -m \"test.txt dal-A icin degistirdim\"\n[dal-A 8cd6f22] test.txt dal-A icin degistirdim\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n$ git checkout dal-B # dal-B branch'imiz zaten hazir oldugu icin `-b` bayragini kullanmayarak yeni bir branch olusturmaktan kacindik.\nSwitched to branch 'dal-B'\n\n# burada test.txt dosyasini acip ilk satiri yukaridakinden farkli bir sekilde degistirelim. Sonrasinda ise siradaki komuttan devam edelim.\n\n$ cat test.txt\ndal-B icin Hello world satiri yaziyorum\nMerhaba Dunya\nyeni-branch icin merhaba-dunya\ndal B icin degisiklik\n\n$ git add test.txt\n\n$ git commit -m \"test.txt dal-B icin degistirdim\"\n[dal-B 2c6d144] test.txt dal-B icin degistirdim\n 1 file changed, 1 insertion(+), 1 deletion(-)\n</code></pre> <p>\u015eimdi ise merge i\u015fleminden \u00f6nce repository'mizin son haline bakal\u0131m.</p> <pre><code>$ git log --graph --all --oneline\n* 2c6d144 (HEAD -&gt; dal-B) test.txt dal-B icin degistirdim\n| * 8cd6f22 (dal-A) test.txt dal-A icin degistirdim\n|/  \n* cef4e44 (main) dal-B icin degisiklik yaptim\n*   b5b6c09 Merge branch 'yeni-branch'\n|\\  \n| * dc2243f (yeni-branch-2, yeni-branch) yeni-branch icin ilk commitimi atiyorum\n* | 9a63d64 test-2.txt dosyasini ekledim\n|/  \n* 777f68a Dosyaya Merhaba Dunya ekledim\n* 95e7356 Ilk commit\n</code></pre> <p><code>dal-A</code> ve <code>dal-B</code> branch'leri birbirinden ayr\u0131lm\u0131\u015f durumda. <code>dal-A</code> branch'ine ge\u00e7erek <code>dal-B</code> branch'ini merge edelim.</p> <pre><code>$ git checkout dal-A\nSwitched to branch 'dal-A'\n\n$ git merge dal-B\nAuto-merging test.txt\nCONFLICT (content): Merge conflict in test.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n</code></pre> <p>G\u00f6rd\u00fc\u011f\u00fcn\u00fcz gibi bir hata ile kar\u015f\u0131la\u015ft\u0131k. Burada s\u00f6zl\u00fc\u011f\u00fcm\u00fcze yeni bir terimi ekleyebiliriz.</p> <p>Terminoloji</p> <p>Conflict bir git i\u015flemi s\u0131ras\u0131nda bir dosya \u00fczerinde meydana gelen, ve birbirini kapsamayan, yani history'leri farkl\u0131 olan iki farkl\u0131 commit'te meydana gelen de\u011fi\u015fikli\u011fin birbiriyle \u00e7ak\u0131\u015fmas\u0131 durumudur.</p> <p>Bu noktada repository'miz art\u0131k \u00f6zel bir duruma ge\u00e7mi\u015ftir. Git bu merge esnas\u0131nda olu\u015fan conflict'in manuel olarak \u00e7\u00f6z\u00fclmesini beklemektedir. Repository'mizin son durumuna bakarak durum hakk\u0131nda bir fikir sahibi olal\u0131m.</p> <pre><code>$ git status\nOn branch dal-A\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add &lt;file&gt;...\" to mark resolution)\n    both modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n</code></pre> <p>Bu noktada yukar\u0131da git'in de bize a\u00e7\u0131k\u00e7a belirtti\u011fi \u00fczere iki se\u00e7ene\u011fimiz bulunmaktad\u0131r:</p> <ul> <li>Olu\u015fan conflict'i elle \u00e7\u00f6zebilirsiniz.</li> <li>Merge i\u015flemini iptal ederek <code>dal-A</code> branch'ine geri d\u00f6nmektir. Bunu <code>git merge --abort</code> ile yapabilirsiniz.</li> </ul> <p>Bu conflict'i elle \u00e7\u00f6zmek i\u00e7in \u00f6ncelikle conflict olan <code>test.txt</code> dosyam\u0131z\u0131n i\u00e7eri\u011fine g\u00f6z atal\u0131m.</p> <pre><code>$ cat test.txt\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\ndal-A icin Hello world satiri yaziyorum\n=======\ndal-B icin Hello world satiri yaziyorum\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; dal-B\nMerhaba Dunya\nyeni-branch icin merhaba-dunya\ndal B icin degisiklik\n</code></pre> <p>G\u00f6r\u00fcld\u00fc\u011f\u00fc \u00fczere iki branch'te yap\u0131lan farkl\u0131 de\u011fi\u015fiklikler dosyan\u0131n i\u00e7erisinde mevcut ancak aralar\u0131na \u00f6zel i\u015faretleyiciler konularak ayr\u0131lm\u0131\u015f. Burada bu conflict'i elle \u00e7\u00f6zmek i\u00e7in bu dosyay\u0131 bir text editor yard\u0131m\u0131yla a\u00e7arak son halinin nas\u0131l olmas\u0131n\u0131 istedi\u011fimize karar vermek.</p> <p>Bu \u00f6rne\u011fimiz a\u00e7\u0131s\u0131ndan bir editor yard\u0131m\u0131 ile <code>dal-B</code> branch'inden gelen sat\u0131r\u0131 tutup kalan\u0131n\u0131 silerek devam edebiliriz. Daha sonras\u0131nda ise merge i\u015flemine devam edelim.</p> <pre><code>$ cat test.txt\ndal-B icin Hello world satiri yaziyorum\nMerhaba Dunya\nyeni-branch icin merhaba-dunya\ndal B icin degisiklik\n\n$ git add test.txt\n\n$ git merge --continue # acilan editor ile merge commit'imizin mesajini duzenleyerek kaydedip kapatalim.\n[dal-A eb02546] Merge branch 'dal-B' into dal-A\n</code></pre> <p>Merge i\u015flemini ba\u015far\u0131l\u0131 bir \u015fekilde tamamlad\u0131ktan sonra <code>git log</code> \u015fu \u015fekilde g\u00f6r\u00fcnecektir.</p> <pre><code>$ git log --graph --all --oneline --parents\n*   eb02546 8cd6f22 2c6d144 (HEAD -&gt; dal-A) Merge branch 'dal-B' into dal-A\n|\\  \n| * 2c6d144 cef4e44 (dal-B) test.txt dal-B icin degistirdim\n* | 8cd6f22 cef4e44 test.txt dal-A icin degistirdim\n|/  \n* cef4e44 b5b6c09 (main) dal-B icin degisiklik yaptim\n*   b5b6c09 9a63d64 dc2243f Merge branch 'yeni-branch'\n|\\  \n| * dc2243f 777f68a (yeni-branch-2, yeni-branch) yeni-branch icin ilk commitimi atiyorum\n* | 9a63d64 777f68a test-2.txt dosyasini ekledim\n|/  \n* 777f68a 95e7356 Dosyaya Merhaba Dunya ekledim\n* 95e7356 Ilk commit\n</code></pre> <p>2 adet parent commit'e bakan yeni bir merge commit ile iki commit dal\u0131 birbirine ba\u015far\u0131l\u0131 bir \u015fekilde ba\u011flanm\u0131\u015f ve <code>dal-A</code> branch'i bu yeni commit'e ta\u015f\u0131nm\u0131\u015f durumda.</p> <p>Merge Commit'inde de\u011fi\u015fiklik</p> <p>E\u011fer ki bu conflict'i \u00e7\u00f6zerken <code>test.txt</code> \u00fczerinde git'in index'inde bulunmayan farkl\u0131 bir de\u011fi\u015fiklik yapm\u0131\u015f olsayd\u0131k, \u00f6rne\u011fin yeni bir sat\u0131ra yeni bir yaz\u0131 ekleseydik, merge commit'imizde bu de\u011fi\u015fiklik yer alacakt\u0131. <pre><code>$ git show 3bfac7d\ncommit 3bfac7da6102da926b2ad4f319f22e3c617c26c8 (HEAD -&gt; dal-A)\nMerge: a1ef269 f3a666a\nAuthor: &lt;username&gt; &lt;email&gt;\nDate:   Mon Apr 21 18:52:14 2025 +0200\n\nMerge branch 'dal-B' into dal-A\n\ndiff --cc test.txt\nindex f995c5f,2c7ce7b..39d67bc\n--- a/test.txt\n+++ b/test.txt\n@@@ -1,4 -1,4 +1,5 @@@\n- dal-A Hello world\n+ dal-B icin Hello world satiri yaziyorum\n++--&gt; Conflict cozerken bu yeni satiri ekledim &lt;--\n  Merhaba Dunya\n  yeni-branch icin merhaba dunya\n  dal B icin degisiklik\n</code></pre></p>"},{"location":"merge/fast-forward-merge/","title":"Fast-Forward Merge","text":"<p>Bir branch'i di\u011ferine merge etti\u011fimizde merge commit olu\u015fturdu\u011fumuzdan ve bu commit'in birden \u00e7ok parent commit'i oldu\u011fundan bahsetmi\u015ftik. Fakat buna her zaman ihtiyac\u0131m\u0131z olmayabilir. </p> <p>\u00d6rne\u011fin <code>A</code> ve <code>B</code> isminde iki adet branch'imiz oldu\u011funu varsayal\u0131m. <code>A</code> branch'i do\u011frudan <code>B</code> branch'inin ortak atas\u0131 olabilir. Bu durumlarda ekstra bir merge commit'i ile history'mizi kirletmek log'a bakmay\u0131 zorla\u015ft\u0131racakt\u0131r. <code>B</code> branch'i zaten <code>A</code> branch'ini kapsad\u0131\u011f\u0131 i\u00e7in bu iki branch'i birbirine yeni bir commit ile ba\u011flamaya ger\u00e7ekten gerek var m\u0131?</p> <p>Git gibi bir ara\u00e7 kullanman\u0131n bize sa\u011flad\u0131\u011f\u0131 faydalardan birisi de yapt\u0131\u011f\u0131m\u0131z operasyonlar\u0131n sonucunu kendi i\u00e7inde hesaplayarak sadele\u015ftirebilmesi, yani optimize edebilmesidir. Yukar\u0131daki \u00f6rnek durum i\u00e7in asl\u0131nda merge yerine \u00e7ok daha basit bir \u00e7\u00f6z\u00fcm mevcut. <code>A</code> branch'i zaten <code>B</code> branch'inin i\u00e7inde bulundu\u011fu i\u00e7in, yani di\u011fer bir deyi\u015fle <code>B</code> branch'i <code>A</code> branch'ini kapsad\u0131\u011f\u0131 i\u00e7in, <code>B</code> branch'ini <code>A</code> branch'ine merge etmek yerine <code>A</code> branch'inin i\u015faret etti\u011fi commit'i <code>B</code> branch'inin i\u015faret etti\u011fi commit'e de\u011fi\u015ftirerek yine istedi\u011fimiz ayn\u0131 sonuca ula\u015fabiliriz ve b\u00f6ylece fazladan bir merge commit'i olu\u015fturmaktan ka\u00e7\u0131nm\u0131\u015f oluruz. Bu durumu g\u00f6rselle\u015ftirerek daha iyi a\u00e7\u0131klayabiliriz.</p> <p></p> <p>G\u00f6rselde de g\u00f6r\u00fclen bu y\u00f6ntem Git'in bize sa\u011flad\u0131\u011f\u0131 kolayl\u0131klardan birisidir. Bu \u00e7e\u015fit yap\u0131lan merge operasyonlar\u0131na fast-forward merge ad\u0131 verilmektedir. Merge operasyonunu \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131n\u0131zda Git \\(\\text{branch}_B \\supseteq \\text{branch}_A\\) \u00f6nermesini ispatlayabilir ise otomatik olarak fast-forward merge uygulamaktad\u0131r.</p> <p>Bu davran\u0131\u015f\u0131 \u00fczerinde \u00e7al\u0131\u015ft\u0131\u011f\u0131m\u0131z repository'mizde test edebiliriz. \u00d6ncelikle main branch'inin \u00fcst\u00fcne <code>dal-B</code> isminde yeni bir branch a\u00e7al\u0131m ve bir commit atal\u0131m.</p> <pre><code>$ git checkout -b \"dal-B\"\nSwitched to a new branch 'dal-B'\n\n$ echo \"dal B icin degisiklik\" &gt;&gt; test.txt\n\n$ git add test.txt\n\n$ git commit -m \"dal-B icin degisiklik yaptim\"\n[dal-B cef4e44] dal-B icin degisiklik yaptim\n 1 file changed, 1 insertion(+)\n\n$ git log --graph --all --oneline\n* cef4e44 (HEAD -&gt; dal-B) dal-B icin degisiklik yaptim\n*   b5b6c09 (main) Merge branch 'yeni-branch'\n|\\  \n| * dc2243f (yeni-branch-2, yeni-branch) yeni-branch icin ilk commitimi atiyorum\n* | 9a63d64 test-2.txt dosyasini ekledim\n|/  \n* 777f68a Dosyaya Merhaba Dunya ekledim\n* 95e7356 Ilk commit\n</code></pre> <p>Log'dan da g\u00f6r\u00fcld\u00fc\u011f\u00fc \u00fczere <code>dal-B</code> branch'i <code>main</code> branch'ini kaps\u0131yor. \u015eimdi ise <code>main</code> branch'ine ge\u00e7erek <code>dal-B</code> branch'ini merge etmeyi deneyelim.</p> <pre><code>$ git checkout main\nSwitched to branch 'main'\n\n$ git merge dal-B\nUpdating b5b6c09..cef4e44\nFast-forward\n test.txt | 1 +\n 1 file changed, 1 insertion(+)\n</code></pre> <p>Merge komutunu \u00e7al\u0131\u015ft\u0131rd\u0131ktan sonraki \u00e7\u0131kt\u0131da <code>Fast-forward</code> sat\u0131r\u0131 bize fast-forward merge yap\u0131ld\u0131\u011f\u0131n\u0131 g\u00f6stermektedir. \u015eimdi log'umuza bakal\u0131m.</p> <pre><code>$ git log --graph --all --oneline\n* cef4e44 (HEAD -&gt; main, dal-B) dal-B icin degisiklik yaptim\n*   b5b6c09 Merge branch 'yeni-branch'\n|\\  \n| * dc2243f (yeni-branch-2, yeni-branch) yeni-branch icin ilk commitimi atiyorum\n* | 9a63d64 test-2.txt dosyasini ekledim\n|/  \n* 777f68a Dosyaya Merhaba Dunya ekledim\n* 95e7356 Ilk commit\n</code></pre> <p>G\u00f6r\u00fcld\u00fc\u011f\u00fc \u00fczere yeni bir merge commit'i olu\u015fturulmam\u0131\u015f. <code>main</code> branch'inin bakt\u0131\u011f\u0131 commit <code>b5b6c09</code> hash'li commit'ten <code>cef4e44</code> hash'li commit'e de\u011fi\u015ftirilmi\u015f durumda.</p> <p>Fast-forward merge'den ka\u00e7\u0131nmak</p> <p>Baz\u0131 projelerde history'de bir yap\u0131 korunmak istenebiliyor. Bu durumlarda merge operasyonlar\u0131nda fast-forward yerine merge commit'i olu\u015fturma ihtiyac\u0131 olu\u015fabiliyor. Bu durumda merge komutuna <code>--no-ff</code> bayra\u011f\u0131 eklenerek Git'in fast-forward yapmas\u0131n\u0131 engelleyebilirsiniz.</p>"},{"location":"merge/merge-commit/","title":"Branch Merge / Merge Commit","text":"<p>Git bize yapt\u0131\u011f\u0131m\u0131z de\u011fi\u015fiklikleri ay\u0131rmam\u0131za, gruplamam\u0131za, d\u00fczenlememize, geriye almam\u0131za, yani k\u0131saca y\u00f6netmemize olanak sa\u011flayan bir ara\u00e7. Fakat bazen projemizde, veya repository'mizde geldi\u011fimiz noktada iki ayr\u0131 de\u011fi\u015fikli\u011fi birle\u015ftirmeye ihtiya\u00e7 duyabiliyoruz. Bu de\u011fi\u015fikliklerimizi y\u00f6netmek i\u00e7in kulland\u0131\u011f\u0131m\u0131z ara\u00e7, git ayn\u0131 zamanda bu de\u011fi\u015fiklikleri bir arada toplamam\u0131za, veya birle\u015ftirmemize de olanak sa\u011fl\u0131yor.</p> <p>Yukar\u0131ya ek olarak ge\u00e7ti\u011fimiz sayfalarda bir commit'in en az bir parent commit'i olmas\u0131 gerekti\u011finden bahsetmi\u015ftik. Bunun \u00fczerine <code>git commit</code> komutu ile yeni bir commit att\u0131\u011f\u0131m\u0131z zaman olu\u015fan commit'in bir parent commit'e bakt\u0131\u011f\u0131n\u0131 ve bu parent commit'i ile olan ili\u015fkisini ortaya koymu\u015ftuk. En az bir parent commit diyerek bir commit'in birden \u00e7ok parent commit'e de ayn\u0131 anda bakabildi\u011fini de ima ediyoruz. E\u011fer ki <code>git commit</code> ile at\u0131lan commitler sadece 1 parent'e bakabiliyorsa, o halde birden \u00e7ok parent'\u0131 olabilen ba\u015fka bir commit atma y\u00f6nteminin olmas\u0131 gerekiyor. Burada git'in hen\u00fcz de\u011finmedi\u011fimiz bir operasyonundan bahsetmeye ba\u015flayabiliriz.</p> <p>Git bize iki veya daha fazla commit dal\u0131n\u0131, yani iki branch'i tek bir noktada toplamam\u0131za <code>merge</code> komutu ile imkan tan\u0131yor. Bu sayede birbirinden ayr\u0131lm\u0131\u015f iki branch'i tekrar bir araya getirebiliyorsunuz.</p> <p>Terminoloji</p> <p>Merge T\u00fcrk\u00e7ede birle\u015ftirmek, bir araya kar\u0131\u015ft\u0131rmak anlam\u0131na gelir. Git ba\u011flam\u0131nda da anlam\u0131 de\u011fi\u015fmez.</p> <p>Bu <code>merge</code> operasyonunu \u00f6nceki sayfalarda \u00fczerinde \u00e7al\u0131\u015ft\u0131\u011f\u0131m\u0131z repository'miz \u00fczerinde ger\u00e7ekle\u015ftirelim. <code>main</code> branch'imize ge\u00e7ip repository'mizde yeni bir dosya olu\u015fturup commit atal\u0131m. Hemen ard\u0131ndan da commit'imizin yapt\u0131\u011f\u0131 de\u011fi\u015fikli\u011fi g\u00f6sterelim. Bu de\u011fi\u015fikli\u011fi g\u00f6stermek i\u00e7in <code>git show</code> komutunu yeni olu\u015fan commit'in hash'i ile birlikte kullanaca\u011f\u0131z.</p> <pre><code>$ git checkout main\nSwitched to branch 'main'\n\n$ echo \"Lorem ipsum\" &gt; test-2.txt\n\n$ git add test-2.txt\n\n$ git commit -m \"test-2.txt dosyasini ekledim\"\n[main 9a63d64] test-2.txt dosyasini ekledim\n 1 file changed, 1 insertion(+)\n create mode 100644 test-2.txt\n\n$ git show 9a63d64\ncommit 9a63d6499f568868f73613412f881a770f33342d (HEAD -&gt; main)\nAuthor: &lt;username&gt; &lt;email&gt;\nDate:   Fri May 2 21:49:15 2025 +0200\n\n    test-2.txt dosyasini ekledim\n\ndiff --git a/test-2.txt b/test-2.txt\nnew file mode 100644\nindex 0000000..3be11c6\n--- /dev/null\n+++ b/test-2.txt\n@@ -0,0 +1 @@\n+Lorem ipsum\n</code></pre> <p>\u015eimdi repository'mizin log'una bakal\u0131m. Bu sefer <code>--all</code> bayra\u011f\u0131n\u0131 da komutumuza ekleyelim. Bu bayrak ile sadece mevcut branch'in de\u011fil b\u00fct\u00fcn repository'nin log'unu g\u00f6rebiliriz.</p> <pre><code>$ git log --graph --parents --oneline --all\n* 9a63d64 777f68a (HEAD -&gt; main) test-2.txt dosyasini ekledim\n| * dc2243f 777f68a (yeni-branch-2, yeni-branch) yeni-branch icin ilk commitimi atiyorum\n|/  \n* 777f68a 95e7356 Dosyaya Merhaba Dunya ekledim\n* 95e7356 Ilk commit\n</code></pre> <p>Buradan anla\u015f\u0131laca\u011f\u0131 \u00fczere <code>777f68a</code> commit'inden ba\u015flayarak dallanan 2 ayr\u0131 de\u011fi\u015fiklik zincirimiz var. Biri <code>main</code> branch, di\u011feri ise <code>yeni-branch</code> ismindeki branch.</p> <p>Terminoloji</p> <p>Bu noktada repository'mizde <code>777f68a</code> commit'i <code>main</code> ve <code>yeni-branch</code> branch'lerinin common ancestor'u, yani ortak atas\u0131 oluyor.</p> <p><code>yeni-branch</code> ismindeki branch'i <code>main</code> branch'e birle\u015ftirerek asl\u0131nda o dalda yap\u0131lm\u0131\u015f olan de\u011fi\u015fiklikleri, yani <code>main</code> branch'te bulunmay\u0131p <code>yeni-branch</code>'te bulunan commit'leri <code>main</code> branch'ine de almak istedi\u011fimizi varsayal\u0131m. Bu birbirinden farkl\u0131 y\u00f6nlere dallanm\u0131\u015f iki branch'i bir araya getirmek i\u00e7in <code>merge</code> komutunu kullanabiliriz.</p> <p>Text editoru</p> <p>\u00c7al\u0131\u015ft\u0131raca\u011f\u0131m\u0131z <code>merge</code> komutu bizden commit mesaj\u0131n\u0131 d\u00fczenlememizi isteyecek. Bu noktada git'in varsay\u0131lan olarak kulland\u0131\u011f\u0131 <code>vi</code> isimli modal text editor a\u00e7\u0131lacakt\u0131r. Fakat bir\u00e7o\u011fumuz buna a\u015fina olmad\u0131\u011f\u0131 i\u00e7in, bu komutu \u00e7al\u0131\u015ft\u0131rmadan \u00f6nce sizin git'in kullanaca\u011f\u0131 text editorunu <code>vscode</code> veya <code>idea</code> olarak de\u011fi\u015ftirmenizi tavsiye ederim. Bunu a\u015fa\u011f\u0131daki komutlardan birini \u00e7al\u0131\u015ft\u0131rarak sa\u011flayabilirsiniz. <pre><code>$ git config --global core.editor \"code --wait\" # vscode icin\n$ git config --global core.editor \"idea --wait\" # JetBrains IntelliJ icin\n</code></pre></p> <p>Merge Branch'lar\u0131</p> <p>Burada <code>yeni-branch</code> isimli branch'i <code>main</code> isimli branch'e merge ediyoruz. E\u011fer ki merge ba\u015far\u0131l\u0131 olursa <code>main</code> branch'inin bakt\u0131\u011f\u0131 commit g\u00fcncellenirken <code>yeni-branch</code> isimli branch'de hi\u00e7bir de\u011fi\u015fiklik meydana gelmeyecektir.</p> <pre><code>$ git merge yeni-branch\nMerge made by the 'ort' strategy.\n test.txt | 1 +\n 1 file changed, 1 insertion(+)\n</code></pre> <p>Bunu \u00e7al\u0131\u015ft\u0131rd\u0131ktan sonra kar\u015f\u0131n\u0131za a\u00e7\u0131lan text editoru kaydedip \u00e7\u0131karak merge i\u015flemini tamamlayabilirsiniz. \u015eimdi ise repository'mizin son haline bakal\u0131m.</p> <pre><code>$ git log --graph --parents --oneline --all\n*   b5b6c09 9a63d64 dc2243f (HEAD -&gt; main) Merge branch 'yeni-branch'\n|\\  \n| * dc2243f 777f68a (yeni-branch-2, yeni-branch) yeni-branch icin ilk commitimi atiyorum\n* | 9a63d64 777f68a test-2.txt dosyasini ekledim\n|/  \n* 777f68a 95e7356 Dosyaya Merhaba Dunya ekledim\n* 95e7356 Ilk commit\n</code></pre> <p>Buradan da a\u015fikar oldu\u011fu \u00fczere <code>merge</code> komutu ile yeni bir commit olu\u015fturulmu\u015f durumda. <code>main</code> branch'i art\u0131k bu commit'e bak\u0131yor. Bu commit'in hash'i <code>b5b6c09</code> iken, 1 de\u011fil 2 adet parent commit'e, yani <code>9a63d64</code> ve <code>dc2243f</code> commit'lerine bakt\u0131\u011f\u0131n\u0131 g\u00f6rebiliyoruz. Soldaki graf ile bu birle\u015fme terminal ortam\u0131ndaki karakterler ile g\u00f6rselle\u015ftirilmi\u015f. Bu g\u00f6rsellik bize daha karma\u015f\u0131k repository'lerde yard\u0131mc\u0131 olacak.</p> <p>Peki bu merge commit'inin i\u00e7inde ne var? Bunu yukar\u0131da kulland\u0131\u011f\u0131m\u0131z <code>git show</code> komutu ile g\u00f6sterelim.</p> <pre><code>$ git show b5b6c09\ncommit b5b6c0910ab195204dec707b3370b8e70b47eabc (HEAD -&gt; main)\nMerge: 9a63d64 dc2243f\nAuthor: &lt;username&gt; &lt;email&gt;\nDate:   Fri May 2 21:49:17 2025 +0200\n\n    Merge branch 'yeni-branch'\n</code></pre> <p>Burada herhangi bir dosya de\u011fi\u015fikli\u011fi g\u00f6z\u00fckm\u00fcyor iken <code>Merge: 9a63d64 dc2243f</code> sat\u0131r\u0131 g\u00f6z\u00fcm\u00fcze \u00e7arp\u0131yor. Bu commit asl\u0131nda i\u00e7inde herhangi bir de\u011fi\u015fiklik bar\u0131nd\u0131rm\u0131yor ve sadece 2 adet ayr\u0131 commit'e i\u015faret ediyor. Yani asl\u0131nda sadece bir yertutucu g\u00f6revi g\u00f6r\u00fcyor. Bu \u00f6zellikteki commit'lere merge commit ad\u0131 verilmektedir.</p> <p>Merge commit'i de de\u011fi\u015fiklik bar\u0131nd\u0131rabilir</p> <p>\u0130leride conflict terimine de\u011findi\u011fimizde merge commit'lerinin de de\u011fi\u015fiklik bar\u0131nd\u0131rabildi\u011fini g\u00f6rece\u011fiz.</p> <p>Buradan da anla\u015f\u0131laca\u011f\u0131 \u00fczere bir branch'i di\u011ferine merge etmek asl\u0131nda commit'leri kopyalam\u0131yor, birle\u015ftirmiyor, de\u011fi\u015ftirmiyor. Bir branch'i di\u011ferine merge etmek asl\u0131nda commit graf'\u0131na sadece bir d\u00fc\u011f\u00fcm daha ekliyor.</p> <p>Terminoloji</p> <p><code>merge</code> komutu birden fazla branch'i ayn\u0131 anda merge etmemize de olanak sa\u011fl\u0131yor. Bunun sonucunda olu\u015fan merge commit'inin 2'den fazla parent commit'i olabiliyor. Bu y\u00f6ntem ile yap\u0131lan merge i\u015flemlerine octopus merge deniliyor. T\u00fcrk\u00e7ele\u015ftirmek istersek ahtapot birle\u015fimi diyebiliriz ama bu \u00e7ok sa\u011fl\u0131kl\u0131 bir kar\u015f\u0131l\u0131k olmaz.</p> <p>E\u011flenceli Bilgiler</p> <ul> <li> <p>GitHub'un maskotu olan ahtapot kedi Octocat, asl\u0131nda Octopus ismindeki ufak bir kelime oyunundan gelmektedir. Bu fikir \u0130ngilizcede Octo ve Puss isimlerinin birle\u015fiminden olu\u015fan Octopuss isimli bir stok g\u00f6rselden ortaya \u00e7\u0131km\u0131\u015ft\u0131r. Kaynak</p> </li> <li> <p>Linux kernel geli\u015ftirmesi s\u0131ras\u0131nda olu\u015fan 66 parent'li bir merge commit'i hakk\u0131nda bu yaz\u0131y\u0131 okuman\u0131z\u0131 tavsiye ederim.</p> </li> </ul>"},{"location":"merge/squash-merge/","title":"Squash Merge","text":"<p>Ge\u00e7ti\u011fimiz b\u00f6l\u00fcmler sonucunda 2 merge commit'li bir history'miz olu\u015ftu.</p> <pre><code>$ git log --graph --all --oneline\n*   eb02546 (HEAD -&gt; dal-A) Merge branch 'dal-B' into dal-A\n|\\  \n| * 2c6d144 (dal-B) test.txt dal-B icin degistirdim\n* | 8cd6f22 test.txt dal-A icin degistirdim\n|/  \n* cef4e44 (main) dal-B icin degisiklik yaptim\n*   b5b6c09 Merge branch 'yeni-branch'\n|\\  \n| * dc2243f (yeni-branch-2, yeni-branch) yeni-branch icin ilk commitimi atiyorum\n* | 9a63d64 test-2.txt dosyasini ekledim\n|/  \n* 777f68a Dosyaya Merhaba Dunya ekledim\n* 95e7356 Ilk commit\n</code></pre> <p>Fakat bu \u00e7ok boyutlu veya \u00e7ok parent'l\u0131 yap\u0131 bazen repository'i y\u00f6netmemizi zorla\u015ft\u0131rabiliyor. \u00d6rne\u011fin bazen repository'mizde <code>main</code> branch'inin tek boyutlu kalmas\u0131n\u0131 isteyebiliriz. B\u00f6ylece gelecekte <code>main</code> branch'in takip edilmesini ve y\u00f6netilmesinin kolayla\u015fmas\u0131n\u0131 sa\u011flamak istiyoruz. Fakat farkl\u0131 bir branch a\u00e7arak deneysel \u00e7al\u0131\u015fmalar yapmaya ihtiyac\u0131m\u0131z da olabiliyor.</p> <p>Kendimize <code>A</code> isminde yeni bir branch olu\u015fturdu\u011fumuzu ve bunun \u00fczerinde deneysel \u00e7al\u0131\u015fmalar yap\u0131p \u00e7ok say\u0131da commit att\u0131\u011f\u0131m\u0131z\u0131 varsayal\u0131m. Bu branch'te att\u0131\u011f\u0131m\u0131z commit'lerin hepsi anlaml\u0131 commit'ler olmayabilir ve o commit'lerin \u00e7o\u011funun sadece o branch'te kalmas\u0131n\u0131 istiyoruz. <code>main</code> branch'e <code>A</code> branch'ini merge etmek istiyoruz ama <code>A</code> branch'inde meydana gelen b\u00fct\u00fcn geli\u015ftirme s\u00fcrecinden ziyade sadece <code>A</code> branch'inin sonucunu almak istiyoruz. B\u00f6ylece <code>main</code> branch'inin de dal yap\u0131s\u0131n\u0131n tek boyutta kalmas\u0131n\u0131 sa\u011flamak istiyoruz.</p> <p>Bu senaryoda ger\u00e7ekle\u015ftirmek istedi\u011fimiz eylemi squash merge olarak adland\u0131rabiliriz. Asl\u0131nda yapmak istedi\u011fimiz \u015fey <code>A</code> branch'indeki b\u00fct\u00fcn commit'leri s\u0131k\u0131\u015ft\u0131r\u0131p yeni bir commit olarak <code>main</code> branch'e eklemek olarak sadele\u015ftirilebilir. Bunu ger\u00e7ekle\u015ftirmek i\u00e7in merge esnas\u0131nda <code>--squash</code> bayra\u011f\u0131n\u0131 kullanmam\u0131z yeterli olacakt\u0131r.</p> <p>\u00d6rnek olarak <code>dal-A</code> ve <code>dal-B</code> branch'lerini ele alal\u0131m. <code>dal-B</code> branch'ine ge\u00e7ip 2 tane commit atal\u0131m. Bu commit'lerden sonra <code>dal-B</code> branch'ini <code>dal-A</code> branch'ine merge etmek isteyece\u011fiz.</p> <pre><code>$ git checkout dal-B\nSwitched to branch 'dal-B'\n\n$ echo \"Degisiklik-1\" &gt;&gt; test.txt\n\n$ git add test.txt\n\n$ git commit -m \"degisiklik-1\"\n[dal-B 8dd8796] degisiklik-1\n 1 file changed, 1 insertion(+)\n\n$ echo \"Degisiklik-2\" &gt;&gt; test.txt\n\n$ git add test.txt\n\n$ git commit -m \"degisiklik-2\"\n[dal-B 5fa6930] degisiklik-2\n 1 file changed, 1 insertion(+)\n\n$ cat test.txt\ndal-B icin Hello world satiri yaziyorum\nMerhaba Dunya\nyeni-branch icin merhaba-dunya\ndal B icin degisiklik\nDegisiklik-1\nDegisiklik-2\n</code></pre> <p><code>dal-B</code> \u00fczerinde 2 commit atarak <code>test.txt</code> dosyas\u0131na 2 de\u011fi\u015fiklik yapt\u0131k. \u015eimdi ise <code>dal-A</code> branch'ine ge\u00e7erek squash merge yapmay\u0131 deneyelim.</p> <pre><code>$ git checkout dal-A\nSwitched to branch 'dal-A'\n\n$ git merge --squash dal-B\nAutomatic merge went well; stopped before committing as requested\nSquash commit -- not updating HEAD\n\n$ git status\nOn branch dal-A\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\n    modified:   test.txt\n</code></pre> <p><code>git status</code> komutunun \u00e7\u0131kt\u0131s\u0131ndan da anla\u015f\u0131laca\u011f\u0131 \u00fczere \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131m\u0131z <code>merge</code> otomatik olarak bir commit atmad\u0131. Onun yerine <code>dal-B</code> branch'indeki de\u011fi\u015fiklikleri index'e ekledi. Bu durumda commit'i kendimiz elle tamamlamam\u0131z gerekiyor.</p> <p><pre><code>$ git commit -m \"squash merge dal-B\"\n[dal-A 7894926] squash merge dal-B\n 1 file changed, 2 insertions(+)\n\n$ git log --graph --all --oneline\n* 7894926 (HEAD -&gt; dal-A) squash merge dal-B\n*   eb02546 Merge branch 'dal-B' into dal-A\n|\\  \n* | 8cd6f22 test.txt dal-A icin degistirdim\n| | * 5fa6930 (dal-B) degisiklik-2\n| | * 8dd8796 degisiklik-1\n| |/  \n| * 2c6d144 test.txt dal-B icin degistirdim\n|/  \n* cef4e44 (main) dal-B icin degisiklik yaptim\n*   b5b6c09 Merge branch 'yeni-branch'\n|\\  \n| * dc2243f (yeni-branch-2, yeni-branch) yeni-branch icin ilk commitimi atiyorum\n* | 9a63d64 test-2.txt dosyasini ekledim\n|/  \n* 777f68a Dosyaya Merhaba Dunya ekledim\n* 95e7356 Ilk commit\n</code></pre> <pre><code>$ cat test.txt\ndal-B icin Hello world satiri yaziyorum\nMerhaba Dunya\nyeni-branch icin merhaba-dunya\ndal B icin degisiklik\nDegisiklik-1\nDegisiklik-2\n</code></pre></p> <p>Commit'i ger\u00e7ekle\u015ftirdikten sonra log'dan da g\u00f6rebilece\u011fimiz \u00fczere asl\u0131nda bir merge commit'i olu\u015fmad\u0131. Onun yerine sadece kendisinden \u00f6nceki commit'e bakan yeni bir commit olu\u015ftu ve bu yeni commit ile birlikte <code>dal-B</code> branch'inde <code>test.txt</code> dosyas\u0131na yapt\u0131\u011f\u0131m\u0131z de\u011fi\u015fiklikler art\u0131k <code>dal-A</code> branch'inde mevcut hale geldi.</p>"},{"location":"objeler/bir-commitin-anatomisi/","title":"Bir Commit'in Anatomisi","text":"<p>Commit'ler bir git repository'sinin yap\u0131ta\u015f\u0131d\u0131r. Bir repository'nin kilometre ta\u015f\u0131 olarak isimlendirebiliriz. Repository'mizin ge\u00e7mi\u015fte hangi a\u015famalardan ge\u00e7ti\u011fini g\u00f6sterir. Repository ge\u00e7mi\u015finde kay\u0131t alt\u0131na al\u0131nan bu de\u011fi\u015fiklikleri bir ki\u015fiye atfeder. Repository'miz \u00fczerinde farkl\u0131 durumlara ge\u00e7ip farkl\u0131 \u00e7al\u0131\u015fmalar yapmam\u0131za olanak tan\u0131r. Hen\u00fcz ana ak\u0131ma almaya haz\u0131r olmad\u0131\u011f\u0131m\u0131z de\u011fi\u015fiklikleri ayr\u0131 tutmam\u0131za olanak tan\u0131r. Ve t\u00fcm bu \u00f6zellikleri git kullan\u0131c\u0131dan soyutlanm\u0131\u015f bir \u015fekilde sa\u011flar. Commit'ler kal\u0131c\u0131 halde saklanmalar\u0131na ra\u011fmen repository'mizin dosyalar\u0131 aras\u0131nda yer tutmazlar. Bize g\u00f6r\u00fcnmez bir \u015fekilde varl\u0131klar\u0131n\u0131 s\u00fcrd\u00fcr\u00fcrler. Peki kilometre ta\u015flar\u0131m\u0131z olan bu commit'ler nerede?</p> <p>Yaz\u0131m\u0131z\u0131n giri\u015finde bir repository dizininde bulunan <code>.git</code> dizinin i\u00e7eri\u011fine bakm\u0131\u015ft\u0131k ve bu dizinin i\u00e7inde bulundu\u011fu dizine git repository'si olma niteli\u011fi kazand\u0131rd\u0131\u011f\u0131n\u0131 dile getirmi\u015ftik. \u00dczerinde \u00e7al\u0131\u015ft\u0131\u011f\u0131m\u0131z repository'mize yaz\u0131m\u0131z boyunca farkl\u0131 de\u011fi\u015fikliklerde bulunduk. Bu i\u015flemlerin sonucunda repository'mizin <code>.git</code> klas\u00f6r\u00fcne tekrar bakarak, yaz\u0131n\u0131n ba\u015f\u0131ndaki haline k\u0131yasla ne gibi de\u011fi\u015fikliklerin oldu\u011funu g\u00f6zlemleyelim.</p> <pre><code>$ tree .git\n.git\n\u251c\u2500\u2500 config\n\u251c\u2500\u2500 description\n\u251c\u2500\u2500 HEAD\n\u251c\u2500\u2500 hooks\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 applypatch-msg.sample\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 commit-msg.sample\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 fsmonitor-watchman.sample\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 post-update.sample\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 pre-applypatch.sample\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 pre-commit.sample\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 pre-merge-commit.sample\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 pre-push.sample\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 pre-rebase.sample\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 pre-receive.sample\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 prepare-commit-msg.sample\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 push-to-checkout.sample\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sendemail-validate.sample\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 update.sample\n\u251c\u2500\u2500 index\n\u251c\u2500\u2500 info\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 exclude\n\u251c\u2500\u2500 logs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 HEAD\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 refs\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 heads\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 dal-A\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 dal-B\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 main\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 yeni-bir-branch\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 yeni-branch\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 yeni-branch-2\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 remotes\n\u251c\u2500\u2500 objects\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 0d\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 3ca3b82801797f1e43b13e13ff848745f2508e\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 13\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 549709c8a35740ffd8e8807d8d3316f9954ef6\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 bb9e0ba6d7bd9e4087f7cdb110080c10a8249d\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2c\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 6d14409ca7bd4bedf69b1fa2b7df7e673c3c8b\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2f\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 7e211bb943c48fa21d1cd73a0a0ba8ca871f39\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 31\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 f3baeb6bda14f8f02d304999e16df9de956377\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 36\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 7ea1ad26695c83c96a6632563f1118344897c0\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 3b\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 e11c69355948412925fa5e073d76d58ff3afd2\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 40\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 1ce7dbd55d28ea49c1c2f1c1439eb7d2b92427\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 51\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ea971882184ee5986f440bb9e0ed2baea702ae\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 52\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ac9288adff03447ba51676ca78a830d8b69ccb\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 54\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 8d693ac499dffbba69340bfb0b25593473883a\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 5f\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 a69300068f328394fc9765d3a3843d0d6d321a\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 71\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 120a132264f1823a4bf4a42298d1586548716b\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 5c93c23f99d7602214513ee965ee0fe0514aff\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 77\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 7f68a6ba056e0bdfd674c3f8646ea2f9b04520\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 78\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 9492681e6b0d56b1fe142431bae464d630f2d3\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 7e\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 b6f87f0dae69f6a068004caea18eb0b3868e51\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 80\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 2992c4220de19a90767f3000a79a31b98d0df7\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 8c\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 d6f22b567ea17f6ac6f69e20e26d5824a47e7f\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 8d\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 d87969d42bdfaf073149647688bf2c5c0db840\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 8f\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 d49c9aea2c510c690e234cbd31938b188f4f81\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 95\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 e7356f75c2d844d9d1d7ba42fd5b40a5fd5ecf\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 99\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 da6674f09ff4194a01b3380fb5591537a9384c\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 9a\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 63d6499f568868f73613412f881a770f33342d\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 b5\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 b6c0910ab195204dec707b3370b8e70b47eabc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ce\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 f4e449c3fcab258db56a2954cc144ae3271584\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 da\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 9d8ba3ad2add71c335a269ada194455a06831e\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 dc\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 2243f197f26719f94687238bb0f9310da223d2\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 de\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 0bdc0759033f9b112a4d874c8aaff95959f198\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 eb\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 02546d739a068296f32e1340f4754bbbd3e922\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ee\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 cd54119ac8e595f09320298ff46bab502d5861\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ef\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 f951c5a4da7490ac1022508fc98ee4533897db\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 fe\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 b734c0ff9cfb31293961003c8bcf6fadd86514\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 info\n\u251c\u2500\u2500 packed-refs\n\u2514\u2500\u2500 refs\n    \u251c\u2500\u2500 heads\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 dal-A\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 dal-B\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 main\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 yeni-bir-branch\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 yeni-branch\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 yeni-branch-2\n    \u251c\u2500\u2500 remotes\n    \u2514\u2500\u2500 tags\n\n45 directories, 67 files\n</code></pre> <p>Art\u0131k <code>.git</code> dizinimizin i\u00e7inde branch'lerimizi g\u00f6rebiliyoruz. Buna ek olarak <code>objects</code> dizininin alt\u0131nda \u00e7ok say\u0131da kay\u0131t g\u00f6r\u00fcyoruz. <code>objects</code> dizininin i\u00e7inde \u00e7ok say\u0131da 2 harfli dizin, ve o dizinlerin alt\u0131nda da commit hash'lerimize benzeyen kay\u0131tlar g\u00f6r\u00fcyoruz.</p> <p>Bu a\u015famada bu hash gibi ismi olan kay\u0131tlar\u0131n hepsinin asl\u0131nda bizim commit'lerimiz oldu\u011funu d\u00fc\u015f\u00fcnmek i\u00e7in bir varsay\u0131mda bulunabiliriz. Fakat kay\u0131tlar\u0131n say\u0131s\u0131 bizim repository'deki commit'lerimizin say\u0131s\u0131ndan daha fazla gibi g\u00f6z\u00fck\u00fcyor. Bu \u00f6n yarg\u0131m\u0131z do\u011fru mu? Bu \u00f6nermemizin do\u011frulu\u011funu ispatlamaya \u00e7al\u0131\u015fal\u0131m.</p> <p>Unix Bilgisi</p> <p>Buradaki ispat\u0131m\u0131zda <code>wc</code> isimli arac\u0131 kullanaca\u011f\u0131z. <code>wc</code> ismi word count kelimelerinin k\u0131saltmas\u0131ndan gelmektedir. Kendisine beslenen girdi hakk\u0131nda say\u0131m bilgisi verir. Biz <code>-l</code> bayra\u011f\u0131n\u0131 kullanarak girdimizde ka\u00e7 sat\u0131r oldu\u011funu g\u00f6sterece\u011fiz.</p> <p>Buna ek olarak <code>find</code> komutunu kullanarak <code>.git/objects</code> klas\u00f6r\u00fcnde recursive bir \u015fekilde dosya listeleme yapaca\u011f\u0131z. <code>ls</code> yerine <code>find</code> arac\u0131n\u0131 tercih etmemizin sebebi ise her sat\u0131ra yaln\u0131zca bir dosya isminin bas\u0131lmas\u0131na ihtiya\u00e7 duymam\u0131z. Bu ihtiyac\u0131 <code>ls</code> ile ger\u00e7ekle\u015ftirmek bu a\u015fama i\u00e7in gereksiz bir karma\u015f\u0131kl\u0131k meydana getirecektir. Buna ek olarak dizinleri basmamas\u0131n\u0131, yani sadece dosyalar\u0131 basmas\u0131n\u0131 istedi\u011fimiz i\u00e7in <code>-type f</code> bayra\u011f\u0131n\u0131 kullanaca\u011f\u0131z. Bu \u00e7\u0131kt\u0131y\u0131 <code>wc</code> komutuna besleyerek dosya say\u0131s\u0131n\u0131 \u00f6\u011frenece\u011fiz.</p> <pre><code>$ git log --all --oneline | wc -l\n      13\n#     ^^ repository'deki toplam commit sayimiz\n\n$ find .git/objects -type f | wc -l\n      34\n#     ^^ repository'deki toplam obje sayimiz\n</code></pre> <p><code>git log</code> komutunun bize verdi\u011fi bilgiye g\u00f6re repository'mizde sadece <code>13</code> adet commit bulunuyorken <code>.git/objects</code> dizininde <code>34</code> adet kay\u0131t bulunmaktad\u0131r. Bu bulgulardan yola \u00e7\u0131karak repository'mizde mevcutta commit'lerimizden daha fazla objemizin oldu\u011fu sonucuna var\u0131yoruz. Peki commit'lerimiz de bir obje say\u0131l\u0131yor mu? Objelerle birlikte mi saklan\u0131yor?</p> <p>Dikkatli bakarsak <code>.git/objects</code> dizininin alt\u0131nda commit hash'lerimizi bulmam\u0131z m\u00fcmk\u00fcn. Fakat bunu yapmak i\u00e7in normalde yapaca\u011f\u0131m\u0131zdan farkl\u0131 bir y\u00f6ntem izlememiz gerekiyor. Aramak istedi\u011fimiz commit hash'imizin ilk iki karakterini alarak sakland\u0131\u011f\u0131 dizini bulduktan sonra o dizin i\u00e7indeki dosyalarda ismi commit hash'imizin son 38 karakterine e\u015fit olan dosya bizim commit'imiz olacakt\u0131r.</p> <p>\u00d6rnek olarak <code>789492681e6b0d56b1fe142431bae464d630f2d3</code> hash'li commitimiz <code>.git/objects/78/9492681e6b0d56b1fe142431bae464d630f2d3</code> \u015feklinde saklanmaktad\u0131r.</p> <p>Objelerin alt dizinlere ayr\u0131lmas\u0131</p> <p>Bir git repository'sinin yap\u0131s\u0131 gere\u011fi \u00e7ok say\u0131da objeye sahip olmas\u0131 ola\u011fan bir durumdur. Git objeleri <code>objects</code> dizininde saklarken hash'lerinin ilk 2 karakterine g\u00f6re alt dizinlere yerle\u015ftirir. Bu sayede b\u00fcy\u00fck repository'lerde \u00e7ok b\u00fcy\u00fck say\u0131larda objeler olmas\u0131na ra\u011fmen objeler i\u00e7inde arama yapmay\u0131 gerektiren i\u015flemlerin zamansal karma\u015f\u0131kl\u0131\u011f\u0131nda iyile\u015fme sa\u011flan\u0131r. Bu i\u015flem veritaban\u0131 sistemlerinde yap\u0131lan partition i\u015flemiyle benzer bir yakla\u015f\u0131m ortaya koyar.</p> <pre><code>$ ls .git/objects/78/9492681e6b0d56b1fe142431bae464d630f2d3\n.git/objects/78/9492681e6b0d56b1fe142431bae464d630f2d3\n</code></pre> <p>Bu sayede commit'lerimizin bir dosya halinde <code>.git/objects</code> dizininin alt\u0131nda sakland\u0131\u011f\u0131n\u0131 g\u00f6stermi\u015f olduk. Bu noktada commit'lerimizin nas\u0131l sakland\u0131\u011f\u0131n\u0131, hangi formatta sakland\u0131\u011f\u0131n\u0131 ve i\u00e7inde neler bulundu\u011funu da g\u00f6sterelim.</p> <p>Obje Dosyalar\u0131n\u0131n Format\u0131</p> <p>Commit'imiz bir dosya halinde sakland\u0131\u011f\u0131 i\u00e7in <code>cat</code> komutu ile terminalimize bast\u0131rabiliriz ancak git'in objeleri saklamak i\u00e7in kulland\u0131\u011f\u0131 dosya bi\u00e7imi <code>xml</code>, <code>json</code> veya <code>yaml</code> gibi insan taraf\u0131ndan kolayl\u0131kla okunabilecek bir format olmad\u0131\u011f\u0131 i\u00e7in, yani binary bir formatta oldu\u011fu i\u00e7in <code>cat</code> komutunu kullansak bile ekrana belli bir anlam ta\u015f\u0131yan karakterler basmaktan farkl\u0131 bir sonuca ula\u015famay\u0131z.</p> <p>Git'in kendi format\u0131yla saklad\u0131\u011f\u0131 bir git objesinin i\u00e7eri\u011finde ne oldu\u011funu \u00f6\u011frenmek i\u00e7in git'ten yard\u0131m alarak <code>git cat-file</code> komutunu kullanmam\u0131z gerekmektedir. Bu komut ile birlikte git obje dosyas\u0131n\u0131 a\u00e7arak okunabilir bir formatta ekrana basacakt\u0131r. Bu komut yard\u0131m\u0131 ile mevcut commit'imizin anatomisini g\u00f6zden ge\u00e7irebiliriz.</p> <pre><code>$ git cat-file commit 789492681e6b0d56b1fe142431bae464d630f2d3\ntree eecd54119ac8e595f09320298ff46bab502d5861\nparent eb02546d739a068296f32e1340f4754bbbd3e922\nauthor &lt;username&gt; &lt;email&gt; 1746280401 +0200\ncommitter &lt;username&gt; &lt;email&gt; 1746280401 +0200\n\nsquash merge dal-B\n</code></pre> <p>Buradan da a\u00e7\u0131k\u00e7a g\u00f6r\u00fcld\u00fc\u011f\u00fc \u00fczere commit'imizi meydana getiren \u00f6\u011feler \u015funlard\u0131r:</p> <ul> <li>tree</li> <li>parent commit</li> <li>author ki\u015fi ve zaman\u0131</li> <li>commiter ki\u015fi ve zaman\u0131</li> <li>commit mesaj\u0131</li> </ul> <p>Author ve Commiter</p> <p>Bu a\u015famaya kadar bizim git'i kullan\u0131m bi\u00e7imimiz gere\u011fi <code>author</code> ve <code>commiter</code> daima ayn\u0131 ki\u015fiye i\u015faret edecektir. Yaz\u0131ya karma\u015f\u0131kl\u0131k eklemekten ka\u00e7\u0131nmak amac\u0131yla bu iki \u00f6\u011fenin fark\u0131n\u0131 bu a\u015famada a\u00e7\u0131klamaktan ka\u00e7\u0131nmay\u0131 tercih ediyorum.</p> <p>Burada listelenmi\u015f \u00f6\u011felere, <code>tree</code> \u00f6\u011fesi haricinde daha \u00f6nce de\u011finmi\u015ftik. Fakat commit'imizin repository'mizde meydana getirdi\u011fi de\u011fi\u015fiklikleri burada bir \u00f6\u011fe olarak g\u00f6remiyoruz. O halde commit'in yapt\u0131\u011f\u0131 de\u011fi\u015fiklikler nerede saklan\u0131yor?</p> <p>K\u0131lavuzumuzda commit'lere de\u011finirken commit'lerimizin repository'mizin o andaki halinin bir kopyas\u0131n\u0131 saklad\u0131\u011f\u0131ndan bahsetmi\u015ftik. Bu ifade ile commit'lerimizin asl\u0131nda ayr\u0131 ayr\u0131 dosyalarda yapt\u0131\u011f\u0131m\u0131z de\u011fi\u015fiklikleri saklamad\u0131\u011f\u0131n\u0131 dolayl\u0131 olarak ifade etmi\u015f oluyoruz.</p> <p>Commit'ler repository'nin bir kopyas\u0131n\u0131 sakl\u0131yor ifadesi do\u011frudan olmasa da dolayl\u0131 olarak do\u011fru bir ifadedir. Bir commit asl\u0131nda repository'mizin herhangi bir andaki dizin a\u011fac\u0131na i\u015faret etmektedir. Yukar\u0131da listeledi\u011fimiz <code>tree</code> \u00f6\u011fesi asl\u0131nda repository'mizin commit'i att\u0131\u011f\u0131m\u0131z andaki dizin yap\u0131s\u0131n\u0131 recursive bir \u015fekilde saklayan bir objeye i\u015faret etmektedir.</p>"},{"location":"objeler/blob/","title":"Blob","text":"<p>Bir git repository'sindeki dosyalar <code>blob</code> ad\u0131 verilen objeler ile saklanmaktad\u0131r. Bu blob'lar dosyalar\u0131n i\u00e7eriklerini bar\u0131nd\u0131r\u0131rlar.</p> <p>Terminoloji</p> <p>Blob ismi, binary large object kelimelerinin k\u0131salt\u0131lmas\u0131ndan meydana gelen bir terimdir.</p> <p>\u00d6rne\u011fin repository'mizin <code>test.txt</code> isimli dosyas\u0131na kar\u015f\u0131l\u0131k gelen <code>blob</code> objesinin hash'ini commit'imizin i\u015faret etti\u011fi root tree'den bulal\u0131m. Daha sonra bu blob'u <code>cat-file</code> yard\u0131m\u0131 ile ekrana bast\u0131ral\u0131m.</p> <p><pre><code>$ git cat-file -p 49664afeafb81dd195da85101c35bfdb18fd277b\n040000 tree 3b863a1570fbd49a0edddaa19e139d914e8fe5de    alt-dizinim\n100644 blob 3be11c69355948412925fa5e073d76d58ff3afd2    test-2.txt\n100644 blob 52ac9288adff03447ba51676ca78a830d8b69ccb    test.txt\n</code></pre> <pre><code>$ git cat-file -p 52ac9288adff03447ba51676ca78a830d8b69ccb\ndal-B icin Hello world satiri yaziyorum\nMerhaba Dunya\nyeni-branch icin merhaba-dunya\ndal B icin degisiklik\nDegisiklik-1\nDegisiklik-2\n</code></pre></p> <p>Buradan g\u00f6r\u00fcld\u00fc\u011f\u00fc \u00fczere tree'miz bir blob'a i\u015faret etmekte ve bu blob'un hash'ini kullanarak ekrana yazd\u0131rd\u0131\u011f\u0131m\u0131z zaman ise <code>test.txt</code> isimli dosyam\u0131z\u0131n i\u00e7eri\u011fine ula\u015fmaktay\u0131z. Yani her blob, bir dosya i\u00e7eri\u011fini bar\u0131nd\u0131rmaktad\u0131r. Burada bir blob bir dosyaya e\u015fittir gibi bir \u00e7\u0131kar\u0131ma ula\u015fabilsek de bu \u00e7\u0131kar\u0131m tam olarak do\u011fru olmayacakt\u0131r. Blob'lar i\u00e7in bir dosya kavram\u0131 yoktur. Agnostik objelerdir. Sadece bir dosyan\u0131n i\u00e7eri\u011fini bar\u0131nd\u0131r\u0131rlar.</p> <p>Her git objesinde oldu\u011fu gibi blob'lar\u0131n hash'leri de blob'un i\u00e7erece\u011fi bilgiler hesaba kat\u0131larak hesaplan\u0131r. Bir dosyan\u0131n i\u00e7erisinde de\u011fi\u015fiklik yapt\u0131\u011f\u0131n\u0131z zaman bu de\u011fi\u015fiklik sonucunda olu\u015fan yeni dosya i\u00e7eri\u011fi hesaba kat\u0131larak bir hash \u00fcretilmesi gerekir. Ancak i\u00e7eri\u011fin de\u011fi\u015fmesiyle birlikte \u00fcretilecek olan bu hash da de\u011fi\u015fece\u011fi i\u00e7in yeni bir blob olu\u015fturulmas\u0131 gerekmektedir. <code>git add</code> komutu ile bir dosyada yapt\u0131\u011f\u0131m\u0131z de\u011fi\u015fikli\u011fi git'in index'ine ekledi\u011fimiz zaman yeni bir hash hesaplanarak yeni bir blob olu\u015fturulmas\u0131 gerekmektedir. Di\u011fer bir deyi\u015fle bir dosyada yap\u0131p kay\u0131t alt\u0131na ald\u0131\u011f\u0131n\u0131z her de\u011fi\u015fiklik sonucunda o dosya i\u00e7in yeni bir blob olu\u015fturulmaktad\u0131r.</p> <p>\u00d6rnek olarak <code>test.txt</code> isimli dosyam\u0131z\u0131n meydana getirdi\u011fi blob'un hash'ini elle hesaplayal\u0131m.</p> <pre><code># blob hash'i icin olusturmamiz gereken format:\n#\n# blob &lt;dosyanin-boyut&gt;\\0&lt;dosyanin-icerigi&gt;\\n\n#\n# sonrasinda bu formatin sha1 ile hash'ini alacagiz\n$ BOYUT=\"$(cat test.txt | wc -c | tr -d ' ')\"\n\n$ ICERIK=\"$(cat test.txt)\"\n\n$ printf \"blob ${BOYUT}\\0${ICERIK}\\n\" | sha1sum\n52ac9288adff03447ba51676ca78a830d8b69ccb  -\n</code></pre> <p>Unix Bilgisi</p> <p>Burada dosyan\u0131n boyutunu hesaplamak i\u00e7in dosyay\u0131 <code>cat</code> ile okuyarak \u00e7\u0131kt\u0131s\u0131n\u0131 <code>wc</code> komutuna y\u00f6nlendirdik. <code>wc</code> komutunu <code>-c</code> bayra\u011f\u0131 ile kullanarak girdinin ka\u00e7 bayt oldu\u011funu \u00e7\u0131kartt\u0131k. Ancak <code>wc</code> komutunun \u00e7\u0131kt\u0131s\u0131nda fazladan bo\u015fluk karakteri oldu\u011fu i\u00e7in <code>tr -d ' '</code> ile bu karakterleri sildirdik. Aksi taktirde bu fazladan bo\u015fluk karakterleri hesaplayaca\u011f\u0131m\u0131z hash'i etkileyerek farkl\u0131 bir sonu\u00e7 \u00e7\u0131karacakt\u0131.</p> <p>Bunun yerine git'in <code>hash-object</code> komutunu kullanarak da ayn\u0131 sonuca ula\u015fabiliriz.</p> <pre><code>$ git hash-object test.txt\n52ac9288adff03447ba51676ca78a830d8b69ccb\n</code></pre> <p>Blob hakk\u0131nda bildiklerimizi genelle\u015ftirirsek:</p> <ul> <li>Blob'lar bir dosyan\u0131n o andaki kopyas\u0131n\u0131 tutmaktad\u0131r.</li> <li>Blob'lar\u0131n kimlikleri hash'leridir.</li> <li>Bir dosya i\u00e7eri\u011finde kay\u0131t edilen her de\u011fi\u015fiklik yeni bir blob olu\u015fturur.</li> <li>Blob'lar anonimdir.</li> <li>Blob'lara mekan niteli\u011fini tree'ler atfeder.</li> <li>Blob'lara dosya isimlerini tree'ler atfeder.</li> </ul>"},{"location":"objeler/tree/","title":"Tree","text":"<p>Git, bir repository'deki dizinlerin yap\u0131s\u0131n\u0131 <code>tree</code> ad\u0131 verilen objeler ile saklamaktad\u0131r. Tree objeleri ile repository'mizin dosya sistemi bilgisi, hangi dizinde hangi dizinlerin ve hangi dosyalar\u0131n oldu\u011funu, bu dizin ve dosyalar\u0131n izin bilgileri bir arada saklanmaktad\u0131r.</p> <p>Terminoloji</p> <p>Bir commit'in i\u015faret etti\u011fi <code>tree</code> objesine root tree ad\u0131 verilir. Root tree'ler repository'mizin k\u00f6k dizin yap\u0131s\u0131n\u0131 bar\u0131nd\u0131r\u0131rlar.</p> <p>Tree objesini daha iyi a\u00e7\u0131klayabilmek i\u00e7in repository'mizde klas\u00f6rler olu\u015fturup bu klas\u00f6rlerin i\u00e7inde dosyalar olu\u015fturup bir commit atal\u0131m.</p> <p><pre><code>$ mkdir alt-dizinim &amp;&amp; echo \"bu bir testtir\" &gt; alt-dizinim/alt-dosya.txt\n\n$ mkdir alt-dizinim/bir-baska-alt-dizin &amp;&amp; echo \"baska bir test\" &gt; alt-dizinim/bir-baska-alt-dizin/baska-alt-dosya.txt\n\n$ git add . &amp;&amp; git commit -m \"alt dizinlerle dosyalar olusturdum\"\n[dal-A 255a1c9] alt dizinlerle dosyalar olusturdum\n 2 files changed, 2 insertions(+)\n create mode 100644 alt-dizinim/alt-dosya.txt\n create mode 100644 alt-dizinim/bir-baska-alt-dizin/baska-alt-dosya.txt\n</code></pre> <pre><code># repository dizinimizin son haline bakalim\n$ tree .\n.\n\u251c\u2500\u2500 alt-dizinim\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 alt-dosya.txt\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 bir-baska-alt-dizin\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 baska-alt-dosya.txt\n\u251c\u2500\u2500 test-2.txt\n\u2514\u2500\u2500 test.txt\n\n3 directories, 4 files\n</code></pre></p> <p><code>cat-file</code> komutu yard\u0131m\u0131yla mevcut commit'imizin i\u015faret etti\u011fi root tree'ye bakal\u0131m.</p> <p><code>-p</code> Bayra\u011f\u0131</p> <p>Yaz\u0131n\u0131n bu noktas\u0131ndan itibaren <code>cat-file</code> komutunu <code>-p</code> bayra\u011f\u0131 ile kullanaca\u011f\u0131m. Aksi halde <code>tree</code> objeleri ekrana bozuk karakterler ile bas\u0131lacakt\u0131r.</p> <pre><code>$ git cat-file -p 255a1c9\ntree 49664afeafb81dd195da85101c35bfdb18fd277b\nparent 789492681e6b0d56b1fe142431bae464d630f2d3\nauthor &lt;username&gt; &lt;email&gt; 1747583059 +0200\ncommitter &lt;username&gt; &lt;email&gt; 1747583059 +0200\n\nalt dizinlerle dosyalar olusturdum\n\n$ git cat-file -p 49664afeafb81dd195da85101c35bfdb18fd277b\n040000 tree 3b863a1570fbd49a0edddaa19e139d914e8fe5de    alt-dizinim\n100644 blob 3be11c69355948412925fa5e073d76d58ff3afd2    test-2.txt\n100644 blob 52ac9288adff03447ba51676ca78a830d8b69ccb    test.txt\n</code></pre> <p>Yukar\u0131da da g\u00f6r\u00fcld\u00fc\u011f\u00fc \u00fczere mevcut commit'imizin i\u015faret etti\u011fi root tree objesi repository'mizde olu\u015fturdu\u011fumuz dosyalar\u0131m\u0131z\u0131 <code>blob</code> isminde bir obje tipi ve bu objelerin hash'leri ile i\u015faret etmektedir.</p> <p>Unix Bilgisi</p> <p>Tree objemizin listeledi\u011fi <code>blob</code> objelerinin ba\u015f\u0131nda yer alan <code>100644</code> say\u0131s\u0131 Unix sistemlerde bir dosyan\u0131n tipini ve kimlerin bu dosyaya eri\u015febildi\u011fini g\u00f6steren bir kodlama y\u00f6ntemidir. <code>100644</code> kodu bize dosyan\u0131n \u00e7al\u0131\u015ft\u0131r\u0131lamaz bir dosya oldu\u011funu ve bu dosyaya sadece dosya sahibinin yazma i\u015flemi yapabilece\u011fini ifade etmektedir.</p> <p><code>040000</code> ise bize bunun bir dizin oldu\u011funu s\u00f6ylemektedir.</p> <p>Burada dikkatimizi \u00e7eken bir ba\u015fka unsur ise root tree'mizin i\u00e7erdi\u011fi bir ba\u015fka \u00f6\u011fe olan <code>alt-dizinim</code> isimli bir ba\u015fka tree. Root tree'miz asl\u0131nda bir alt dizini bir tree objesi olarak i\u015faret etmekte. Peki bu <code>alt-dizinim</code> tree'sinin \u00f6\u011feleri neler?</p> <pre><code>$ git cat-file -p 3b863a1570fbd49a0edddaa19e139d914e8fe5de\n100644 blob 855deee8a88ad1a89440c6e868e326e14c2d55a4    alt-dosya.txt\n040000 tree b23821ed42fc628b9cdd2d16bf14ed3c7f5bffb6    bir-baska-alt-dizin\n</code></pre> <p>Bu alt dizinin tree objesi de ayn\u0131 \u015fekilde bir <code>blob</code> ve bir alt tree tipi i\u00e7ermekte. Genelle\u015ftirirsek:</p> <ul> <li>Her tree kendi ba\u011flamlar\u0131nda anonimdir. Hash'leri d\u0131\u015f\u0131nda bir kimlikleri yoktur.</li> <li>Bir tree bir ba\u015fka tree'ye i\u015faret ederken tree'nin hash'i ile birlikte bir isim atfedebilir.</li> <li>Her tree i\u00e7inde bar\u0131nd\u0131rd\u0131\u011f\u0131 <code>blob</code> ve <code>tree</code>lerin hash'lerini i\u015faret eder.</li> <li>Bir commit'in i\u015faret etti\u011fi <code>tree</code> objesine root tree denir.</li> <li>Root tree'den ba\u015flayarak i\u015faret edilen <code>blob</code> ve <code>tree</code>leri recursive bir \u015fekilde gezersek commit'imizin at\u0131ld\u0131\u011f\u0131 esnadaki repository'nin dizin yap\u0131s\u0131n\u0131 olu\u015fturabiliriz.</li> </ul>"},{"location":"temeller/branch/","title":"Branch","text":"<p>\u0130lk commitlerimizi att\u0131k ve art\u0131k 2 committen olu\u015fan bir git repository'sine sahibiz.</p> <pre><code>$ git log --graph\n* commit 777f68a6ba056e0bdfd674c3f8646ea2f9b04520 (HEAD -&gt; main)\n| Author: &lt;username&gt; &lt;email&gt;\n| Date:   Fri May 2 21:49:04 2025 +0200\n| \n|     Dosyaya Merhaba Dunya ekledim\n| \n* commit 95e7356f75c2d844d9d1d7ba42fd5b40a5fd5ecf\n  Author: &lt;username&gt; &lt;email&gt;\n  Date:   Fri May 2 21:49:02 2025 +0200\n\n      Ilk commit\n</code></pre> <p>\u015eimdi ise git'in bir ba\u015fka temeli olan bir branch olu\u015ftural\u0131m. Branch'imizin ad\u0131n\u0131 <code>yeni-branch</code> diyelim. Hemen ard\u0131ndan ise git'i bu branch'e ge\u00e7irelim, yani checkout ettirelim. Son olarak da repository'de bulunan b\u00fct\u00fcn branch'leri listeleyelim.</p> <p>Terminoloji</p> <p>Branch T\u00fcrk\u00e7ede bir b\u00fct\u00fcn\u00fcn bir alt dal\u0131 anlam\u0131na gelmektedir. A\u011fa\u00e7 dal\u0131, e\u011fitim dal\u0131 gibi ba\u011flamlardaki kullan\u0131m\u0131 \u00f6rnek g\u00f6sterilebilir. Git ba\u011flam\u0131nda ise branch dallanan, bir noktadan ayr\u0131lan commit'leri i\u015faret etmek i\u00e7in kullan\u0131l\u0131r.</p> <pre><code>$ git branch yeni-branch\n\n$ git checkout yeni-branch\nSwitched to branch 'yeni-branch'\n\n$ git branch\n  main\n* yeni-branch\n</code></pre> <p>K\u0131sayol</p> <p>Burada tek bir eylem i\u00e7in iki ayr\u0131 komutunun bulunmas\u0131n\u0131n sebebi checkout komutunun farkl\u0131 bir i\u015flevinin olmas\u0131d\u0131r. Tek komut ile yeni bir branch olu\u015fturup ona checkout etmek i\u00e7in <code>git checkout -b yeni-branch</code> yapabilirsiniz.</p> <p>Peki bu yapt\u0131\u011f\u0131m\u0131z eylemler ne i\u015fe yarad\u0131? Bir branch olu\u015fturduk ve ona ge\u00e7tik ancak bu bize ne sa\u011flad\u0131 ki? Repository'de neler de\u011fi\u015fti? Bu noktada asl\u0131nda bir branch'in somut olarak neye d\u00f6n\u00fc\u015ft\u00fc\u011f\u00fcn\u00fc anlamam\u0131z gerekli.</p> <p>Bu sorunun cevab\u0131 i\u00e7in bir \u00f6nceki sayfada da bahsetti\u011fimiz <code>.git</code> klas\u00f6r\u00fcn\u00fcn i\u00e7ine bakal\u0131m. Yeni bir branch olu\u015fturunca burada git ne yap\u0131yor olabilir?</p> <pre><code>$ ls .git/refs/heads\nmain\nyeni-branch\n</code></pre> <p>Burada 2 adet dosya olu\u015fmu\u015f g\u00f6r\u00fcn\u00fcyor. Dosyalar\u0131n isimleri ise repository'mizdeki branch'lerin isimleri ile uyu\u015fuyor. Peki bu dosyalar\u0131n i\u00e7inde ne bulunuyor?</p> <pre><code>$ cat .git/refs/heads/main\n777f68a6ba056e0bdfd674c3f8646ea2f9b04520\n\n$ cat .git/refs/heads/yeni-branch\n777f68a6ba056e0bdfd674c3f8646ea2f9b04520\n</code></pre> <p>\u0130\u00e7lerinde bir hash bulunuyor ve bu hash bizim son commit'imizin hash'i ile ayn\u0131. Yani branch'ler asl\u0131nda bir commit'e i\u015faret eden bir dosyadan ibaretler. Bunu <code>git log</code> \u00e7al\u0131\u015ft\u0131rarak da g\u00f6rebiliriz.</p> <pre><code>$ git log --graph\n* commit 777f68a6ba056e0bdfd674c3f8646ea2f9b04520 (HEAD -&gt; yeni-branch, main)\n| Author: &lt;username&gt; &lt;email&gt;\n| Date:   Fri May 2 21:49:04 2025 +0200\n| \n|     Dosyaya Merhaba Dunya ekledim\n| \n* commit 95e7356f75c2d844d9d1d7ba42fd5b40a5fd5ecf\n  Author: &lt;username&gt; &lt;email&gt;\n  Date:   Fri May 2 21:49:02 2025 +0200\n\n      Ilk commit\n</code></pre> <p>Burada <code>777f68a6ba056e0bdfd674c3f8646ea2f9b04520</code> hash'li commit'imize <code>yeni-branch</code> ve <code>main</code> branch'lerinin i\u015faret etti\u011fini commit hash'inin yan\u0131nda bulunan <code>(HEAD -&gt; yeni-branch, main)</code> b\u00f6l\u00fcm\u00fc ile g\u00f6rebiliyoruz.</p> <p>\u015eimdi yeni bir commit daha atal\u0131m ve sonras\u0131nda <code>git log</code> ile repository'mize tekrar bakal\u0131m.</p> <pre><code>$ echo \"yeni-branch icin merhaba-dunya\" &gt;&gt; test.txt\n\n$ git add test.txt\n\n$ git commit -m \"yeni-branch icin ilk commitimi atiyorum\"\n[yeni-branch dc2243f] yeni-branch icin ilk commitimi atiyorum\n 1 file changed, 1 insertion(+)\n\n$ git log --graph\n* commit dc2243f197f26719f94687238bb0f9310da223d2 (HEAD -&gt; yeni-branch)\n| Author: &lt;username&gt; &lt;email&gt;\n| Date:   Fri May 2 21:49:11 2025 +0200\n| \n|     yeni-branch icin ilk commitimi atiyorum\n| \n* commit 777f68a6ba056e0bdfd674c3f8646ea2f9b04520 (main)\n| Author: &lt;username&gt; &lt;email&gt;\n| Date:   Fri May 2 21:49:04 2025 +0200\n| \n|     Dosyaya Merhaba Dunya ekledim\n| \n* commit 95e7356f75c2d844d9d1d7ba42fd5b40a5fd5ecf\n  Author: &lt;username&gt; &lt;email&gt;\n  Date:   Fri May 2 21:49:02 2025 +0200\n\n      Ilk commit\n</code></pre> <p><code>main</code> branch'imiz hala bir \u00f6nceki commit'e i\u015faret ediyorken <code>yeni-branch</code> isimli branch'imiz yeni att\u0131\u011f\u0131m\u0131z <code>dc2243f197f26719f94687238bb0f9310da223d2</code> hash'li commit'e i\u015faret etmekte. Peki <code>.git</code> klas\u00f6r\u00fcnde ne de\u011fi\u015fiklik oldu?</p> <pre><code>$ cat .git/refs/heads/main\n777f68a6ba056e0bdfd674c3f8646ea2f9b04520\n\n$ cat .git/refs/heads/yeni-branch\ndc2243f197f26719f94687238bb0f9310da223d2\n</code></pre> <p>Yukar\u0131s\u0131 bize g\u00f6steriyor ki sadece <code>yeni-branch</code> dosyas\u0131n\u0131n i\u00e7indeki hash de\u011fi\u015fmi\u015f durumda. Yani git terminolojisinde branch dedi\u011fimiz temel yap\u0131 asl\u0131nda sadece bir commit i\u015faret\u00e7isi olarak \u00e7al\u0131\u015f\u0131yor. Biz o branch'teyken ne kadar commit atarsak atal\u0131m asl\u0131nda sadece son att\u0131\u011f\u0131m\u0131z commit'in hash'\u0131na i\u015faret eden bir dosyadan ibaret. Bu dizinde bir dosya olu\u015fturarak yeni bir git branch'i olu\u015fturabildi\u011fimizi gelin test edelim.</p> <pre><code>$ git branch\n  main\n* yeni-branch\n\n$ echo \"dc2243f197f26719f94687238bb0f9310da223d2\" &gt; .git/refs/heads/yeni-branch-2\n\n$ git branch\n  main\n* yeni-branch\n  yeni-branch-2\n\n$ git checkout yeni-branch-2\nSwitched to branch 'yeni-branch-2'\n</code></pre> <p>Yukar\u0131daki <code>echo</code> komutu ile bir commit hash'ini <code>.git/refs/heads</code> dizininde yeni bir dosyaya yazd\u0131rd\u0131k. Bunun sonucunda da git'in yeni branch'imizi tan\u0131d\u0131\u011f\u0131n\u0131 g\u00f6rm\u00fc\u015f olduk. Buradan anla\u015f\u0131l\u0131yor ki branch yap\u0131s\u0131 \u00f6nceki att\u0131\u011f\u0131m\u0131z commit'lerin bir listesini herhangi bir yerde tutmuyor. Peki o zaman git bu commit'lerin ve branch'lerin takibini nas\u0131l yap\u0131yor?</p>"},{"location":"temeller/checkout/","title":"Checkout","text":"<p>\u0130lk commit\u2019lerimizi atarak repository\u2019mizde iki d\u00fc\u011f\u00fcml\u00fc bir de\u011fi\u015fiklik a\u011fac\u0131 olu\u015fturduk.</p> <pre><code>$ git log --graph\n* commit 777f68a6ba056e0bdfd674c3f8646ea2f9b04520 (HEAD -&gt; main)\n| Author: &lt;username&gt; &lt;email&gt;\n| Date:   Fri May 2 21:49:04 2025 +0200\n| \n|     Dosyaya Merhaba Dunya ekledim\n| \n* commit 95e7356f75c2d844d9d1d7ba42fd5b40a5fd5ecf\n  Author: &lt;username&gt; &lt;email&gt;\n  Date:   Fri May 2 21:49:02 2025 +0200\n\n      Ilk commit\n</code></pre> <p>Burada s\u0131ralanan her d\u00fc\u011f\u00fcm asl\u0131nda repository\u2019mizin o commit\u2019in at\u0131ld\u0131\u011f\u0131 andaki yap\u0131s\u0131n\u0131 bire bir i\u00e7ermektedir. Di\u011fer bir deyi\u015fle bu commit\u2019lerin her biri repository\u2019mizin o andaki bir kopyas\u0131n\u0131 temsil etmektedir. Repository\u2019mizde yap\u0131lan her de\u011fi\u015fiklik \u00fczerine repository\u2019mizin son h\u00e2lini elle yedeklemek yerine bir commit atarak kay\u0131t alt\u0131na al\u0131yoruz.</p> <p>Bir kopyadan di\u011ferine, veya di\u011fer bir deyi\u015f ile bir commit\u2019ten di\u011ferine ge\u00e7erek dosyalar\u0131 incelemek istersek <code>checkout</code> komutunu kullanabiliriz. \u00d6rne\u011fin bir \u00f6nceki commit\u2019imiz olan <code>95e7356f75c2d844d9d1d7ba42fd5b40a5fd5ecf</code> hash\u2019li commit\u2019e \u015fu \u015fekilde d\u00f6nebiliriz:</p> <p>Daha k\u0131sa hash</p> <p>Bir git commit\u2019inin hash\u2019i 40 karakterden olu\u015fuyor. Ancak git ile \u00e7al\u0131\u015f\u0131rken s\u00fcrekli 40 karakterin tamam\u0131n\u0131 girmek \u00e7ok verimli bir y\u00f6ntem de\u011fil. Bunun yerine genellikle ilk 7 karakteri girmeniz yeterli oluyor.</p> <p>K\u0131sa Hash\u2019i \u00c7ak\u0131\u015fan Commit\u2019ler</p> <p>Bir repository\u2019de ilk 7 karakteri ayn\u0131 olan iki commit\u2019in denk gelme ihtimali \\(16^7 = 268,\\!435,\\!456\\)\u2019d\u0131r. Dolay\u0131s\u0131yla bu ihtimal olduk\u00e7a d\u00fc\u015f\u00fck. Bunun ya\u015fand\u0131\u011f\u0131 durumda \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131n\u0131z git komutu hata atacakt\u0131r.</p> <pre><code>$ git checkout 95e7356\nNote: switching to '95e7356'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by switching back to a branch.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -c with the switch command. Example:\n\n  git switch -c &lt;new-branch-name&gt;\n\nOr undo this operation with:\n\n  git switch -\n\nTurn off this advice by setting config variable advice.detachedHead to false\n\nHEAD is now at 95e7356 Ilk commit\n</code></pre> <p>Note</p> <p>Burada git\u2019in bize verdi\u011fi uyar\u0131lar\u0131n ve <code>detached HEAD</code> teriminin ne anlama geldi\u011finin ilerleyen zamanlarda edindi\u011fimiz bilgiler \u0131\u015f\u0131\u011f\u0131nda tekrar \u00fczerinden ge\u00e7ece\u011fiz.</p> <p>Son sat\u0131rdaki <code>HEAD is now at 95e7356 Ilk commit</code> \u00e7\u0131kt\u0131s\u0131 ile birlikte repository\u2019mizin o commit\u2019teki kopyas\u0131na ba\u015far\u0131 ile d\u00f6nd\u00fc\u011f\u00fcn\u00fc g\u00f6r\u00fcyoruz. \u015eimdi <code>test.txt</code> dosyas\u0131n\u0131n i\u00e7eri\u011fine bakarsak o andaki h\u00e2line d\u00f6nd\u00fc\u011f\u00fcn\u00fc g\u00f6rece\u011fiz.</p> <pre><code>$ cat test.txt\nHello world\n</code></pre> <p><code>git checkout main</code> komutuyla repository\u2019mizi eski h\u00e2line alarak ile kald\u0131\u011f\u0131m\u0131z yerden devam edelim.</p>"},{"location":"temeller/commit-history/","title":"Commit History","text":"<p>Bence git \u00f6\u011frenirken yap\u0131lan en yayg\u0131n hata bir commit'in tam olarak ne oldu\u011funu anlamamak ve git'i varsay\u0131mlarda bulunarak kullanmaya devam etmek. \u0130nternetteki T\u00fcrk\u00e7e kaynaklar\u0131n bir\u00e7o\u011funun da buna do\u011fru bir \u015fekilde de\u011finemedi\u011fini d\u00fc\u015f\u00fcn\u00fcyorum.</p> <p>Git repository'deki yap\u0131lan de\u011fi\u015fiklikleri gruplamak ve saklamak i\u00e7in commit denilen bir yap\u0131 kullanmaktad\u0131r. Bir commit att\u0131\u011f\u0131m\u0131zda asl\u0131nda o zamanda yapt\u0131\u011f\u0131m\u0131z de\u011fi\u015fiklikler sonucunda repository'deki dosyalar\u0131n son halini bir araya toplayarak git'in veritaban\u0131na kay\u0131t etmi\u015f oluruz.</p> <p>Bir commit, hem bir sahibi olan, yani bir kullan\u0131c\u0131 ad\u0131 ve email ile ba\u011fda\u015ft\u0131r\u0131lan, hem de bir parent commit'i olan bir yap\u0131d\u0131r. Her commit'in en az bir parent commit'i olmak zorundad\u0131r. Bunu <code>git log</code> komutunda <code>--parents</code> bayra\u011f\u0131n\u0131 kullanarak g\u00f6rebiliriz.</p> <p><code>--oneline</code> bayra\u011f\u0131</p> <p>Burada \u00e7\u0131kt\u0131y\u0131 sadele\u015ftirmek i\u00e7in <code>--oneline</code> bayra\u011f\u0131n\u0131 da ekleyelim. B\u00f6ylece log'da her commit art\u0131k sadece 1 sat\u0131r, yani one line yer kaplayacak.</p> <pre><code>$ git log --graph --parents --oneline\n* dc2243f 777f68a (HEAD -&gt; yeni-branch-2, yeni-branch) yeni-branch icin ilk commitimi atiyorum\n* 777f68a 95e7356 (main) Dosyaya Merhaba Dunya ekledim\n* 95e7356 Ilk commit\n</code></pre> <ul> <li><code>--oneline</code> bayra\u011f\u0131 ile art\u0131k log'da her sat\u0131r bir commit'e denk geliyor ve hash'lar\u0131n sadece ilk 7 karakteri yaz\u0131l\u0131yor.</li> <li><code>--parents</code> bayra\u011f\u0131 ile her sat\u0131r\u0131n ba\u015f\u0131nda 2 adet farkl\u0131 hash bulunuyor. \u0130lk hash commit'in kendi hash'i iken ikinci hash ise parent commit'in hash'i oluyor.</li> </ul> <p>Log'da da g\u00f6r\u00fclebilece\u011fi \u00fczere asl\u0131nda commit'lerimiz aras\u0131nda linked list'e benzer, geriye d\u00f6n\u00fck bir graf yap\u0131s\u0131 bulunmaktad\u0131r. Commit'ler kendilerinden \u00f6nce gelen commit'leri, yani parent commit'i i\u015faret ederek bir a\u011fa\u00e7 olu\u015ftururlar.</p> <p>Terminoloji</p> <p>Parent i\u00e7in T\u00fcrk\u00e7e bir terim bulamad\u0131m. Burada bir \u00f6nceki commit veya ata commit diye d\u00fc\u015f\u00fcnebiliriz.</p> <p>En az bir parent</p> <p>Gelecekte baz\u0131 commit'lerin birden \u00e7ok parent'\u0131 olabildi\u011fini g\u00f6rece\u011fiz. Burada bir istisna olarak bir repository'de at\u0131lan ilk commit'i \u00f6rnek g\u00f6sterebiliriz. \u0130lk oldu\u011fu i\u00e7in o commit'in bir parent'\u0131 bulunmamaktad\u0131r.</p> <p>Bu bilgilerin \u0131\u015f\u0131\u011f\u0131nda ge\u00e7ti\u011fimiz sayfada haz\u0131rlad\u0131\u011f\u0131m\u0131z repository'i \u00fczerinde yapt\u0131\u011f\u0131m\u0131z de\u011fi\u015fiklikler sonucunda \u015fekillenen b\u00fct\u00fcn commit history'i \u015fu \u015fekilde g\u00f6rselle\u015ftirebiliriz.</p> <p>Terminoloji</p> <p>Commit history bir git repository'sindeki, genelde bir branch'e ait, commit graf\u0131 veya commit ge\u00e7mi\u015fi anlam\u0131nda kullan\u0131l\u0131r.</p> <p></p> <p>Buradan yola \u00e7\u0131karak, bir branch'in commit history'de basit\u00e7e bir noktaya i\u015faret eden bir referans oldu\u011fu sonucuna varabiliriz. Commit hash'leri kullanmak yerine branch'leri kullanman\u0131n bize faydalar\u0131n\u0131 \u015fu \u015fekilde listeleyebiliriz:</p> <ul> <li>Bu i\u015faretler sayesinde istedi\u011fimiz bir commit dal\u0131na commit hash'leri yerine daha okunabilir ve hat\u0131rlanabilir isimler ile i\u015faret edebiliyoruz.</li> <li>Commit hash'leri sabit ve spesifik bir commit'e i\u015faret edebiliyorken branch'lerin i\u015faret etti\u011fi, veya \"bakt\u0131\u011f\u0131\" commit'ler de\u011fi\u015febiliyor. Bu da bize baz\u0131 durumlarda, \u00f6rne\u011fin yapt\u0131\u011f\u0131m\u0131z de\u011fi\u015fiklikleri bir zincir olarak gruplamak ve isimlendirmek istedi\u011fimiz durumlarda, esneklik sa\u011fl\u0131yor.</li> </ul>"},{"location":"temeller/commit/","title":"Commit","text":"<p>Commit atabilmemiz i\u00e7in \u00f6ncelikle repository i\u00e7erisinde bir de\u011fi\u015fiklik yapmam\u0131z gerekli. Burada <code>test.txt</code> isminde bir dosya olu\u015fturarak i\u00e7erisine <code>Hello world</code> yazd\u0131rabiliriz.</p> <pre><code>$ echo \"Hello world\" &gt; test.txt\n</code></pre> <p>Unix Bilgisi</p> <p><code>echo</code> komutu yazd\u0131\u011f\u0131m\u0131z metni tekrar etmeye yarayan bir komuttur. Yukar\u0131da ise echo'nun \u00e7\u0131kt\u0131s\u0131n\u0131n <code>&gt;</code> ile <code>test.txt</code> isminde bir dosyaya y\u00f6nlendirilmesini sa\u011flad\u0131k. Bu dosya e\u011fer ki yoksa otomatik olarak olu\u015fturulmaktad\u0131r. Bu dosyan\u0131n i\u00e7eri\u011fini do\u011frulamak i\u00e7in <code>cat test.txt</code> komutunu \u00e7al\u0131\u015ft\u0131rabilirsiniz.</p> <p>\u015eimdi ise <code>git</code> yapt\u0131\u011f\u0131m\u0131z de\u011fi\u015fikli\u011fi g\u00f6rebiliyor mu bunu <code>git status</code> ile kontrol edelim.</p> <pre><code>$ git status\nOn branch main\n\nNo commits yet\n\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n    test.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n</code></pre> <p>Burada g\u00f6r\u00fclebilece\u011fi \u00fczere git olu\u015fturdu\u011fumuz <code>test.txt</code> dosyas\u0131n\u0131 <code>Untracked files</code> alt\u0131nda listelemi\u015f durumda. <code>Untracked</code> asl\u0131nda bu dosyan\u0131n hen\u00fcz git taraf\u0131ndan repository veritaban\u0131na kaydedilmemi\u015f oldu\u011funu belirtmekte. Bu a\u015famada h\u00e2l\u00e2 bir commit atam\u0131yoruz \u00e7\u00fcnk\u00fc bu dosyay\u0131 hen\u00fcz git'e, daha do\u011frusu git'in index'ine eklemedik. Gelin ekleyelim.</p> <pre><code>$ git add test.txt\n\n$ git status\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached &lt;file&gt;...\" to unstage)\n    new file:   test.txt\n</code></pre> <p>Ekledi\u011fimiz dosyan\u0131n <code>new file</code> olarak listelendi\u011fini g\u00f6rebiliyoruz. Art\u0131k commit atmaya haz\u0131r\u0131z. Commit mesaj\u0131m\u0131za <code>\u0130lk commit</code> yazarak ilk commit\u2019imizi atabiliriz.</p> <p>Commit Sahipli\u011fi</p> <p>Bir git repository'sinde at\u0131lan commit\u2019lerin bir sahibi olmak zorundad\u0131r. Biz hen\u00fcz git'e kendi kullan\u0131c\u0131 ad\u0131 ve e-posta adresimizi tan\u0131tmad\u0131k. A\u015fa\u011f\u0131daki komutlar ile git\u2019in ayarlar\u0131na bunu eklemeyi unutmayal\u0131m. <pre><code>$ git config --global user.name \"&lt;username&gt;\"\n$ git config --global user.email \"&lt;email&gt;\"\n</code></pre></p> <pre><code>$ git commit -m \"Ilk commit\"\n[main (root-commit) 95e7356] Ilk commit\n 1 file changed, 1 insertion(+)\n create mode 100644 test.txt\n</code></pre> <p>Art\u0131k ilk commit\u2019imizi atm\u0131\u015f durumday\u0131z. Repository\u2019mizin ge\u00e7mi\u015fine bakarak bunu onaylayal\u0131m.</p> <pre><code>$ git log\ncommit 95e7356f75c2d844d9d1d7ba42fd5b40a5fd5ecf (HEAD -&gt; main)\nAuthor: &lt;username&gt; &lt;email&gt;\nDate:   Fri May 2 21:49:02 2025 +0200\n\n    Ilk commit\n</code></pre> <p>Art\u0131k repository\u2019mizde hash\u2019i <code>95e7356f75c2d844d9d1d7ba42fd5b40a5fd5ecf</code> olan bir commit\u2019imiz bulunmakta. \u015eimdi gelin minik bir de\u011fi\u015fiklik yap\u0131p ikinci bir commit daha atal\u0131m. Bu sefer <code>test.txt</code> dosyas\u0131nda ufak bir de\u011fi\u015fiklik yapal\u0131m.</p> <pre><code>$ echo \"Merhaba Dunya\" &gt;&gt; test.txt\n\n$ git status\nOn branch main\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n    modified:   test.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n</code></pre> <p>Unix Bilgisi</p> <p>Bu sefer <code>echo</code> komutundan sonra <code>&gt;</code> yerine <code>&gt;&gt;</code> operat\u00f6r\u00fc kullanmam\u0131z\u0131n sebebi <code>test.txt</code> dosyas\u0131n\u0131n i\u00e7eri\u011finin \u00fczerine yazmak yerine komutun \u00e7\u0131kt\u0131s\u0131n\u0131n dosyan\u0131n sonuna eklenmesini istiyoruz. <code>&gt;</code> operat\u00f6r\u00fc dosyan\u0131n i\u00e7eri\u011finin tamam\u0131n\u0131 silerken <code>&gt;&gt;</code> operat\u00f6r\u00fc sadece dosyan\u0131n sonuna ekleme yapmaktad\u0131r.</p> <p>G\u00f6rd\u00fc\u011f\u00fcn\u00fcz \u00fczere bu sefer yapt\u0131\u011f\u0131m\u0131z de\u011fi\u015fikliklere ra\u011fmen dosya <code>Untracked</code> olarak isimlendirilmiyor. Bunun sebebi ise bir \u00f6nceki att\u0131\u011f\u0131m\u0131z commit ile birlikte bu dosyan\u0131n mevcut durumda git\u2019in index\u2019inde zaten yer al\u0131yor olmas\u0131. Art\u0131k yapt\u0131\u011f\u0131m\u0131z de\u011fi\u015fiklik <code>modified</code> olarak g\u00f6z\u00fck\u00fcyor. Bu sefer dosyan\u0131n yeni h\u00e2lini git\u2019in index\u2019ine eklememiz gerekiyor.</p> <pre><code>$ git add test.txt\n\n$ git status\nOn branch main\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\n    modified:   test.txt\n</code></pre> <p>\u015eimdi yeni bir commit atabiliriz.</p> <pre><code>$ git commit -m \"Dosyaya Merhaba Dunya ekledim\"\n[main 777f68a] Dosyaya Merhaba Dunya ekledim\n 1 file changed, 1 insertion(+)\n</code></pre> <p>Art\u0131k repository\u2019mizin en son h\u00e2line bakabiliriz. Bu sefer <code>git log</code> komutumuza <code>--graph</code> bayra\u011f\u0131n\u0131 ekleyerek bakal\u0131m.</p> <pre><code>$ git log --graph\n* commit 777f68a6ba056e0bdfd674c3f8646ea2f9b04520 (HEAD -&gt; main)\n| Author: &lt;username&gt; &lt;email&gt;\n| Date:   Fri May 2 21:49:04 2025 +0200\n| \n|     Dosyaya Merhaba Dunya ekledim\n| \n* commit 95e7356f75c2d844d9d1d7ba42fd5b40a5fd5ecf\n  Author: &lt;username&gt; &lt;email&gt;\n  Date:   Fri May 2 21:49:02 2025 +0200\n\n      Ilk commit\n</code></pre> <p>Art\u0131k yeni bir commit\u2019imiz var ve hash\u2019i <code>777f68a6ba056e0bdfd674c3f8646ea2f9b04520</code> olarak olu\u015fmu\u015f. Ve bir \u00f6nceki commit\u2019e de ba\u011flant\u0131s\u0131 <code>*</code> ve \u00fczerindeki \u00e7izgiler ile g\u00f6sterilmi\u015f durumda. E\u011fer ki commit\u2019lerin yapt\u0131\u011f\u0131 de\u011fi\u015fiklikleri de burada g\u00f6rmek isterseniz <code>log</code> komutuna <code>--patch</code> bayra\u011f\u0131n\u0131 ekleyebilirsiniz.</p> <pre><code>$ git log --graph --patch\n* commit 777f68a6ba056e0bdfd674c3f8646ea2f9b04520 (HEAD -&gt; main)\n| Author: &lt;username&gt; &lt;email&gt;\n| Date:   Fri May 2 21:49:04 2025 +0200\n| \n|     Dosyaya Merhaba Dunya ekledim\n| \n| diff --git a/test.txt b/test.txt\n| index 802992c..da9d8ba 100644\n| --- a/test.txt\n| +++ b/test.txt\n| @@ -1 +1,2 @@\n|  Hello world\n| +Merhaba Dunya\n| \n* commit 95e7356f75c2d844d9d1d7ba42fd5b40a5fd5ecf\n  Author: &lt;username&gt; &lt;email&gt;\n  Date:   Fri May 2 21:49:02 2025 +0200\n\n      Ilk commit\n\n  diff --git a/test.txt b/test.txt\n  new file mode 100644\n  index 0000000..802992c\n  --- /dev/null\n  +++ b/test.txt\n  @@ -0,0 +1 @@\n  +Hello world\n</code></pre>"},{"location":"temeller/repository/","title":"Repository","text":"<p>Git ile \u00e7al\u0131\u015fmaya ba\u015flamadan \u00f6nce ilk yapmam\u0131z gereken \u015fey ya zaten repository olan bir klas\u00f6re ge\u00e7mek, ya da yeni bir klas\u00f6rde repository olu\u015fturmak.</p> <p>Biz yeni bir klas\u00f6r olu\u015fturup repository olu\u015fturarak ba\u015flayaca\u011f\u0131z. \u00d6ncelikle <code>git-kilavuzu-calisma</code> ad\u0131nda bir klas\u00f6r olu\u015fturup i\u00e7ine girerek bir git repository'si olu\u015fturaca\u011f\u0131z.</p> <pre><code>$ mkdir git-kilavuzu-calisma &amp;&amp; cd git-kilavuzu-calisma\n\n$ git init\n\nInitialized empty Git repository in ...../git-kilavuzu-calisma/.git/\n</code></pre> <p>Unix Bilgisi</p> <p>Shell ortam\u0131nda iki komutu <code>&amp;&amp;</code> operat\u00f6r\u00fc ile zincirleme olarak \u00e7al\u0131\u015ft\u0131rabilirsiniz. B\u00f6ylece ilk komut ba\u015far\u0131s\u0131z olursa ikinci komut hi\u00e7 \u00e7al\u0131\u015fmayacakt\u0131r.</p> <p>Peki <code>git init</code> komutu bize ne sa\u011flad\u0131? \u0130lk bak\u0131\u015fta klas\u00f6r\u00fcn i\u00e7inde de\u011fi\u015fen hi\u00e7bir \u015fey g\u00f6remiyor olabilirsiniz. Ancak art\u0131k klas\u00f6r\u00fcn i\u00e7inde <code>.git</code> isminde gizli bir klas\u00f6r olu\u015fmu\u015f durumda. </p> <p>Unix Bilgisi</p> <p>Bu klas\u00f6r\u00fcn gizli olmas\u0131n\u0131n sebebi isminin <code>.</code> karakteri ile ba\u015fl\u0131yor olmas\u0131d\u0131r. E\u011fer ki Unix bazl\u0131 bir sistemdeyseniz bu varsay\u0131lan bir davran\u0131\u015ft\u0131r. Bu davran\u0131\u015f\u0131 klas\u00f6r\u00fcn i\u00e7inde <code>ls</code> komutu \u00e7al\u0131\u015ft\u0131r\u0131p terminalde hi\u00e7bir \u015feyin listelenmedi\u011fini g\u00f6rerek do\u011frulayabilirsiniz. Ancak <code>ls -a</code> \u015feklinde \u00e7al\u0131\u015ft\u0131rd\u0131\u011f\u0131n\u0131zda bu klas\u00f6r\u00fcn varl\u0131\u011f\u0131n\u0131 g\u00f6rebilirsiniz.</p> <p>Bu <code>.git</code> klas\u00f6r\u00fcn\u00fcn bulunmas\u0131 mevcut klas\u00f6re bir git repository\u2019si olma niteli\u011fi kazand\u0131r\u0131yor. Peki bu klas\u00f6r\u00fcn i\u00e7inde neler var?</p> <pre><code>$ tree .git\n.git\n\u251c\u2500\u2500 HEAD\n\u251c\u2500\u2500 config\n\u251c\u2500\u2500 description\n\u251c\u2500\u2500 hooks\n\u2502   \u251c\u2500\u2500 applypatch-msg.sample\n\u2502   \u251c\u2500\u2500 commit-msg.sample\n\u2502   \u251c\u2500\u2500 fsmonitor-watchman.sample\n\u2502   \u251c\u2500\u2500 post-update.sample\n\u2502   \u251c\u2500\u2500 pre-applypatch.sample\n\u2502   \u251c\u2500\u2500 pre-commit.sample\n\u2502   \u251c\u2500\u2500 pre-merge-commit.sample\n\u2502   \u251c\u2500\u2500 pre-push.sample\n\u2502   \u251c\u2500\u2500 pre-rebase.sample\n\u2502   \u251c\u2500\u2500 pre-receive.sample\n\u2502   \u251c\u2500\u2500 prepare-commit-msg.sample\n\u2502   \u251c\u2500\u2500 push-to-checkout.sample\n\u2502   \u251c\u2500\u2500 sendemail-validate.sample\n\u2502   \u2514\u2500\u2500 update.sample\n\u251c\u2500\u2500 info\n\u2502   \u2514\u2500\u2500 exclude\n\u251c\u2500\u2500 objects\n\u2502   \u251c\u2500\u2500 info\n\u2502   \u2514\u2500\u2500 pack\n\u2514\u2500\u2500 refs\n    \u251c\u2500\u2500 heads\n    \u2514\u2500\u2500 tags\n\n9 directories, 18 files\n</code></pre> <p>Burada \u00e7ok fazla dosya ve klas\u00f6r listelenmi\u015f durumda. Hangi klas\u00f6r ne i\u015fe yar\u0131yor? Bir git repository\u2019si bu kadar bilgi mi i\u00e7eriyor? Bunlara yava\u015f yava\u015f ilerleyen zamanlarda de\u011finece\u011fiz. \u015eimdi en temel git yap\u0131lar\u0131ndan biri olan bir commit atmay\u0131 deneyelim.</p>"}]}